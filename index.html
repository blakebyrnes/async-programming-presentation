<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Asynchronous Programming Techniques</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">
		<link rel="stylesheet" href="css/preso.css" >

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
        <style>
            @-webkit-keyframes blur-anim {
                from { -webkit-filter: blur(0); }
                to { -webkit-filter: blur(6px); }
            }
            @-webkit-keyframes opac-anim {
                from { -webkit-filter: opacity(100%); }
                to { -webkit-filter: opacity(20%); }
            }
            @-webkit-keyframes opac-anim-60 {
                from { -webkit-filter: opacity(100%); }
                to { -webkit-filter: opacity(60%); }
            }
            @-webkit-keyframes fade-in {
                 from { -webkit-filter: opacity(0%); }
                 to { -webkit-filter: opacity(100%); }
             }
             /*-webkit-animation: blur-anim 2s linear, opac-anim 2s linear; -webkit-animation-direction: alternate;*/
            .backgrounds .bg-blur {
                -webkit-filter: blur(6px) opacity(20%);
            }
            .backgrounds .bg-slight-blur {
                -webkit-filter: blur(2px) opacity(50%);
            }

            .backgrounds .bg-fade {
                -webkit-filter: blur(1px) opacity(60%);
            }
            .backgrounds .bg-big-fade {
                -webkit-filter: blur(1px) opacity(20%);
            }
            !h2 ~ section.hide-title.present,section.hide-title.hide-title.present + h1 {
                display: none !important;
            }
            h2.shadow,h3.shadow {
                text-shadow: 2px 4px 3px rgba(0,0,0,0.3);
            }
            h2.shadow-light {
                 text-shadow: 4px 0 4px rgba(255,255,255,0.8);
             }
            h2.border-light,p.border-light {
                  text-shadow: 0 2px  rgba(235,235,235,0.8);
              }
            .reveal .dark h3,.reveal .dark h2, .reveal .dark p,.reveal .dark h1, .reveal .dark h5 {
                color: #fff;
            }
            p {
                font-size: 1.4em !important;
            }
        </style>
        <!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Async Programming</h1>
					<h3>Rope ladders and quicksand shoes</h3>
					<p>
						<small>Created by <a href="http://bluefletch.com">Blake Byrnes</a> / <a href="http://twitter.com/blakebyrnes">@blakebyrnes</a></small>
					</p>
                    <aside class="notes">
                        <br/>Basics
                        <br/>Pitfalls
                        <br/>Patterns
                    </aside>
				</section>

				<section class="bg-big-fade" data-background-image="images/caseybluefletch.jpg">
					<h2>Who am I?</h2>
                    <h3>Blake Byrnes</h3>
					<h4>
						CTO of BlueFletch Mobile
					</h4>
					<q>
						I work with: <em>iOS, Android, nodejs, html5/ionic/cordova, AWS and sometimes .NET, backend Java</em>
					</q>
				</section>

                <section>
                    <h2>Agenda</h2>
                    <ul>
                        <li>Why present on async</li>
                        <li>What is it</li>
                        <li>What can go wrong</li>
                        <li>Where async is used</li>
                        <li>Patterns</li>
                        <li>Tips and Tricks</li>
                        <li>Questions</li>
                    </ul>
                </section>

                <section class="dark" data-background-image="images/1d5741309ea65303b436ce736f0acca10c88b06552b42184650cb8b4119e036b.jpg">
                    <h2 class="shadow">Why are you here?</h2>
                    <aside class="notes">
                        Poll group - why are you here
                    </aside>
                </section>

                <section data-background-image="images/Napoleon-Dynamite-skills-gif.gif" data-background-size="contain" data-background="white center" data-background-repeat="no-repeat"
                        >
                    <aside class="notes">
                        All know skills are important, what are yours?
                        <br/>Poll group - language skills
                    </aside>
                </section>

				<!-- -->
				<section>
					 <section  class="bg-blur" data-background-image="images/nm5.jpg">
                         <h2>Why I think we're here</h2>
                         <aside class="notes">
                             Shifts going on in industry.  Building more API-based back-ends, rich front-ends with multiple clients

                         </aside>
					</section>
                    <section class="bg-blur" data-background-image="images/rise_of_mobile-1280x880.jpg">
                        <h1>Rise of Mobile</h1>
                        <aside class="notes">
                            Poll audience on how many are doing mobile apps, or interested
                            <br/><br/>
                            Inherently asynchronous env (threading no longer your concern like backend)
                        </aside>
                    </section>
                    <section class="bg-blur" data-background-image="images/WB0977873.png">
                        <h1>Single Page Apps</h1>
                        <aside class="notes">
                            Angular, Backbone, ExtJS (enterprise), PhoneGap (Ionic)
                            <br/><br/>
                            Ask how many people are working with one of these
                        </aside>
                    </section>

                    <section class="bg-blur" data-background-image="images/node-js.jpg">
                        <h1>Server Side Javascript</h1>
                        <aside class="notes">

                            Javascript is eating the world
                        </aside>
                    </section>

                    <section>
                        <h3>But I already know async...</h3>
                       	<pre ><code data-trim style="font-size:40px !important">
$("#button").click(function(e){
  console.log("handle async.");
});
                        </code></pre>
                        <aside class="notes">
                            Client side - handle events
                        </aside>
                    </section>
                    <section data-background-image="images/EasyButton.jpg">
                        <aside class="notes">
                            Some of you are saying, I went to the wrong class. Shit
                        </aside>
                    </section>
                    <section class="dark" data-background-image="images/4.jpg">
                        <h2>It Gets Complicated Quickly</h2>
                        <aside class="notes">
                            Gets a lot harder when you start orchestrating multiple events
                        </aside>
                     </section>

                    <section>
                        <h2>Thinking asynchronously is hard...</h2>
                        <h2 class="fragment">But cheer up, Eventually you'll get it!</h2>
                    </section>
                    <section data-background-image="images/Image-53.png">
                    </section>
                    <section>
                        <h2>Eventually you'll get it...</h2>
                    </section>
                    <section data-background-transition="slide" data-background-size="80%" data-background-image="images/73d71fab45496a6671d670687eb359dd6293817166ddb699f7e1fb44358bad26.jpg">

                    </section>
					<section data-theme="black">
						<h2>You must learn it!</h2>
                        <img src="images/patience-learn-you-must.jpg"/>
					</section>
                    <section data-background="black">
                        <img src="images/You_7900a8_1204562.jpg"/>
                    </section>
					<section>
						<h2>Real Email</h2>
						<p>"I am working on a appcelerator project for android and I see that the AJAX call  is not synchronous..   And because of this, my function (sic) populating the UI from the AJAX response is failing."</p>
                        <aside class="notes">
                            Is this familiar for anyone?
                        </aside>
					</section>
					<section>
						<p>Pseudo-code</p>
						<pre class=" smallest"><code class="javascript">
plugs.prototype.httpReq = function() {
  ...

  xhr.onload = function(e) {
    dataObj = JSON.parse(xhr.responseText)
  };

  xhr.open("GET", url,false);
  // Send the request.
  xhr.send();
};

plugs.prototype.populateData = function(){
  for(var i=0;i dataObj.length;i++) { //CRASH (dataObj is undefined)  
...

plugs.httpReq();
plugs.populateData();
						</code></pre>
						<aside class="notes">
							Developer didn't understand that the asynchronous code would perform out of order from the sequential order on the screen
						</aside>

					</section>
					<section>
						<h2><strong>Don't let this happen to you</strong></h2>
					</section>
					<section data-background-image="images/toolbelt.jpg">
						<h2 class="shadow-light">Add to your toolbelt</h2>
					</section>
				</section>
				<section>
					<h2>What is async?</h2>
					<section data-background-image="images/running-man-05-g.jpg" class="bg-blur">
						<h4>Code that doesn't wait!</h4>
						<p style="font-size: 1.5em">Will execute later</p>
                        <!-- running man picture -->
						<aside class="notes">
							Ever thought as you were leaving, "Remember to lock the door", then you did a bunch of other stuff, and then you finally got to the door, and remembered to lock it.  Kinda like that.
                            <br/><br/>
							Important to talk about how it doesn't block.  Implication is that it can get more out of the CPU where the code is running
						</aside>
					</section>
                    <section data-transition="fade-in" data-background-image="images/running-man-05-g.jpg" >
                     </section>
					<section>
						<p>User Interface</p>
						<!-- show someone about to hit a ui button -->
						<pre style="font-size:35px"><code data-trim>
$("#button").click(function(e){
  console.log("handle async");
});
						</code></pre>
						<aside class="notes">
							Client side - handle events
						</aside>
					</section>
					<section>
						<h4>I/O</h4>
						<p class="fragment">Network (ajax) requests</p>
						<p class="fragment">Database request</p>
						<p class="fragment">File reads/writes</p>
					</section>
					<section>
						<pre class="smaller"><code data-trim>
console.log(1);

$("#button").click();

console.log(2);

console.log(3);

//1
//click
//2
//3
						</code></pre>
					</section>
					<section>
						<pre><code data-trim>
console.log(1);

$("#button").click(function(e){
  console.log(2);
});

console.log(3);

//1
//3
//click: 2
						</code></pre>
					</section>
				</section>

				<section>
					<section data-background-image="images/running_man.png" class="dark">

                        <h2>The run loop</h2>
						<aside class="notes">
							Back to the running man.  He's going to keep running, until he runs into obstacles.
                            <br/>
                            Viewers are prompted once something is about to happen.  "Wait for execute"
						</aside>
					</section>
					<section data-background-image="images/BTm1H.png" data-background="rgba(51,51,44, 255) center" data-background-size="contain"
                            data-background-repeat="no-repeat">
					</section>
					<section>
						<h5>Javascript (aka, the event loop)</h5>
						<pre><code>
  while(queue.waitForMessage()){
    queue.processNextMessage();
  }

</code></pre>
						<aside class="notes">
							In web browsers, messages are added any time an event occurs and there is an event listener attached to it.
						</aside>
					</section>
					<section>
						<h5>Timers Demystified</h5>
						<pre><code>
  setTimeout(delayedFunction, 100);

</code></pre>
<br/>
						<p class="fragment">Just pops onto the event loop after 100 ms*</p>
						<p class="fragment"><i>*kind of</i></p>
						<aside class="notes">
							Calling setTimeout will add a message to the queue after the time passed as second argument. 
						</aside>
					</section>
				</section>
				<section>
					<section class="dark bg-fade" data-background="images/branches.png">
						<h3 class="shadow"><strong>Asynchronous === Multi-Threading?</strong></h3>

						<aside class="notes">
                            - Async not <i>necessarily</i> multi-threaded
                            <br/>
                            - Multi-threading === run heavy process in background
                            <br/>
                            - Language dependent
                            <br/>
                            - If op doesn't require CPU, that operation can be done without spawning another thread (i/o, hardware notification)

							<a href="http://stackoverflow.com/questions/600795/asynchronous-vs-multithreading-is-there-a-difference">stack overflow</a>
						</aside>
					</section>
				</section>
				<section>
					<h1>Ok, got it</h1>
					<h3>Is there anything more?</h3>
				</section>
                <section data-background-size="contain" data-background="black center" data-background-repeat="no-repeat" data-background-image="images/wfg32.gif"></section>

				<section  data-background-color="black" >
					<h2 style="color:#fff">Why is it hard?</h2>
                    <section data-background-image="">

                    </section>
					<section data-background-repeat="no-repeat" data-background-image="images/2000px-Apple_logo_Think_Different_vectorized.svg.png" data-background-size="contain" data-background="black center" >

						<aside class="notes">Different way of thinking</aside>
					</section>
					<section>
                        <img src="images/bttf_time_machine_ebay_lead.jpg"/>
						<aside class="notes">
							Have to start thinking about what will eventually happen.  If this, then this, then this..
                            <br/><br/>
							Log a function to occur eventually, written now
						</aside>

					</section>
					<section>
						<img src="images/meme-functions.jpg">
						<aside class="notes">
							Break it down into units
						</aside>
					</section>

					<section>
						<img style="margin-top:100px" src="images/IMG_3576-copy.jpeg"/>
						<aside class="notes">
							By the time your "asynchronous" code is done, your view might not be there anymore
                            <br/><br/>
							Android example (activity requests a network resource, puts in a callback handler, gone when it returns)
						</aside>
					</section>
					<aside class="notes">
						I've done these callbacks, why is this a big deal?
					</aside>

				</section>

				<section>
					<h2>What can go wrong?</h2>
				</section>

				<section data-background="black">
					<img src="images/Heaven-or-Hell-Arrow-Way-Line-Route.jpg"/>
				</section>
				<section>
					<h3>Add 5 new features</h3>
					<pre class="smallest stretch" ><code>
fs.readdir(source, function(err, files) {
  if (err) {
    console.log('Error finding files: ' + err);
  } else {
    files.forEach(function(filename, fileIndex) {
      console.log(filename);
      gm(source + filename).size(function(err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values);
          aspect = (values.width / values.height);
          widths.forEach(function(width, widthIndex) {
            height = Math.round(width / aspect);
            console.log('resizing ' + filename + 'to ' + height + 'x' + height);
            var fn = destination + 'w' + width + '_' + filename;
            this.resize(width, height).write(fn, function(err) {
              if (err) console.log('Error writing file: ' + err);
            });
          }.bind(this));
        }
      });
    });
  }
});
                    </code></pre>
				</section>
				<section>
					<h3>Example - can't change backend</h3>
					<ol>
						<li class="fragment">Load blog</li>
						<li class="fragment">Load author</li>
						<li class="fragment">Load comments</li>
						<li class="fragment">Load each commentor user profile</li>
					</ol>
				</section>
				<section>
					<pre class="smallest stretch" ><code style="font-size:25px !important; line-height:30px">
var blog = {};
$.get('/blogs/1', function(data){
  blog = data;
  
  $.get('/users/' + data.authorId, function(author){
    blog.author = author;
  });

  $.get('/blogs/1/comments', function(comments){
    blog.comments = comments;
    comments.forEach(function(comment){
      $.get('/users/' + data.authorId, function(author){
        comment.author = author;
      });
    });
  });
});
                    </code></pre>
				</section>

				<section>
					<h2>How it starts</h2>
					<pre class="smallest stretch" ><code class="javascript">
var blog = {};
$.get('/blogs/1', function(data){
  blog = data;

  //NEW! Featured Articles
  if (blog.isFeatured){
    $.get('/ads', function(data){
      //load ad and display in main content div
    }).fail(function(){
      //TODO: download comments/authors like a normal article... copy here??
    });
  } else {
    
    $.get('/users/' + data.authorId, function(author){
      blog.author = author;
    });

    $.get('/blogs/1/comments', function(comments){
      blog.comments = comments;
      comments.forEach(function(comment){
        $.get('/users/' + data.authorId, function(author){
          comment.author = author;
        });
      });
    });
  }
});
                    </code></pre>
				</section>
				<section>
					<section>
						<h2>Small branches continue to nest logic</h2>
					</section>
					<section>
						<h2>Eventually, you lose</h2>
					</section>
					<section>
						<pre class="smallest stretch" ><code class="javascript" data-trim>
_makePostAppend: function( params, body, options, next ){

    var self = this;
    var body;

    if( typeof( next ) !== 'function' ) next = function(){};

    // Check that the method is implemented
    if( ! self.handlePostAppend ){
      self._sendError( next, new self.NotImplementedError( ) );
      return;
    }

    // Check the IDs
    self._checkParamIds( params, body, false, function( err ){  
      self._sendErrorOnErr( err, next, function(){

        self.schema.validate(  body, function( err, body, errors ) {
          self._sendErrorOnErr( err, next, function(){

            if( errors.length ){
              self._sendError( next, new self.UnprocessableEntityError( { errors: errors } ) );
            } else {
             // Fetch the doc
              self.execAllDbFetch( params, body, options, function( err, fullDoc ){
                self._sendErrorOnErr( err, next, function(){
                 self.extrapolateDoc( params, body, options, fullDoc, function( err, doc) {
                    self._sendErrorOnErr( err, next, function(){
                        </code></pre>
					</section>
					<section>
						<h5>continued</h5>
						<pre class="smallest stretch" ><code class="javascript">
               
                      self._castDoc( doc, function( err, doc) {
                        self._sendErrorOnErr( err, next, function(){

                          // Actually check permissions
                          self.checkPermissionsPostAppend( params, body, options, doc, fullDoc, function( err, granted ){
                            self._sendErrorOnErr( err, next, function(){

                              if( ! granted ){
                                self._sendError( next, new self.ForbiddenError() );
                              } else {

                                // Clean up body from things that are not to be submitted
                                //if( self.schema ) self.schema.cleanup( body, 'doNotSave' );
                                self.schema.cleanup( body, 'doNotSave' );

                                // Paranoid check
                                // Make sure that the id property in the body does match
                                // the one passed as last parameter in the list of IDs
                                body[ self.idProperty ] = params[ self.idProperty ];

                                self.execPostDbAppend( params, body, options, doc, fullDoc, function( err, fullDocAfter ){

                        </code></pre>
					</section>
					<section>
						<h5>continued</h5>
						<pre class="smallest stretch" ><code class="javascript">
                                  self._sendErrorOnErr( err, next, function(){
                                    self.extrapolateDoc( params, body, options, fullDocAfter, function( err, doc) {
                                      self._sendErrorOnErr( err, next, function(){

                                        self._castDoc( fullDocAfter, function( err, docAfter) {
                                          self._sendErrorOnErr( err, next, function(){

                                            // Remote request: set headers, and send the doc back (if echo is on)
                                            if( self.remote ){
                                              if( self.echoAfterPostAppend ){

                                                 self.prepareBeforeSend( docAfter, function( err, docAfter ){
                                                   self._sendErrorOnErr( err, next, function(){

                                                      self.afterPostAppend( params, body, options, doc, fullDoc, docAfter, fullDocAfter, function( err ){
                                                        self._sendErrorOnErr( err, next, function(){

                                                          self._res.json( 200, docAfter );

                                                        });
                                                      });
                                                   })
                                                 })
                                              } else { 
                                                self.afterPostAppend( params, body, options, doc, fullDoc, docAfter, fullDocAfter, function( err ){
                        </code></pre>
					</section>
					<section>
						<h5>continued</h5>
						<pre class="smallest stretch" ><code class="javascript">
                                                  self._sendErrorOnErr( err, next, function(){

                                                    self._res.send( 204, '' );

                                                  });
                                                });

                                              }
                                            // Local request: simply return the doc to the asking function
                                            } else {

                                              self.prepareBeforeSend( docAfter, function( err, docAfter ){
                                                self._sendErrorOnErr( err, next, function(){

                                                  self.afterPostAppend( params, body, options, doc, fullDoc, docAfter, fullDocAfter, function( err ){
                                                    self._sendErrorOnErr( err, next, function(){

                                                      next( null, docAfter, self.idProperty );

                                                    })
                                                  })

                                                })
                                              })
                                            }
                        </code></pre>
					</section>
					<section>
						<h5>finally</h5>
						<pre class="smallest stretch" ><code class="javascript">
                                          })
                                        });
                                      });
                                    })
                                  }) // err
                                }) // execPostDbAppend

                              } // granted

                            })
                          }) 

                        }) 
                      }) 
                    })
                  }) 
                }) // err
              }) // checkPermissionsPostAppend
            } // errors.length

          }) // err
        }) // self.validate
      }) // err
    }) // self.validate
  },

                        </code></pre>
					</section>
					<section>
						<pre class="smallest stretch" ><code class="javascript" style="font-size:6px;line-height:4px;">
_makePostAppend: function( params, body, options, next ){

    var self = this;
    var body;

    if( typeof( next ) !== 'function' ) next = function(){};

    // Check that the method is implemented
    if( ! self.handlePostAppend ){
      self._sendError( next, new self.NotImplementedError( ) );
      return;
    }

    // Check the IDs
    self._checkParamIds( params, body, false, function( err ){  
      self._sendErrorOnErr( err, next, function(){

        self.schema.validate(  body, function( err, body, errors ) {
          self._sendErrorOnErr( err, next, function(){

            if( errors.length ){
              self._sendError( next, new self.UnprocessableEntityError( { errors: errors } ) );
            } else {

              // Fetch the doc
              self.execAllDbFetch( params, body, options, function( err, fullDoc ){
                self._sendErrorOnErr( err, next, function(){


                  self.extrapolateDoc( params, body, options, fullDoc, function( err, doc) {
                    self._sendErrorOnErr( err, next, function(){

                      self._castDoc( doc, function( err, doc) {
                        self._sendErrorOnErr( err, next, function(){

                          // Actually check permissions
                          self.checkPermissionsPostAppend( params, body, options, doc, fullDoc, function( err, granted ){
                            self._sendErrorOnErr( err, next, function(){

                              if( ! granted ){
                                self._sendError( next, new self.ForbiddenError() );
                              } else {

                                // Clean up body from things that are not to be submitted
                                //if( self.schema ) self.schema.cleanup( body, 'doNotSave' );
                                self.schema.cleanup( body, 'doNotSave' );

                                // Paranoid check
                                // Make sure that the id property in the body does match
                                // the one passed as last parameter in the list of IDs
                                body[ self.idProperty ] = params[ self.idProperty ];

                                self.execPostDbAppend( params, body, options, doc, fullDoc, function( err, fullDocAfter ){
                                  self._sendErrorOnErr( err, next, function(){

                                    self.extrapolateDoc( params, body, options, fullDocAfter, function( err, doc) {
                                      self._sendErrorOnErr( err, next, function(){

                                        self._castDoc( fullDocAfter, function( err, docAfter) {
                                          self._sendErrorOnErr( err, next, function(){

                                            // Remote request: set headers, and send the doc back (if echo is on)
                                            if( self.remote ){
                                              if( self.echoAfterPostAppend ){

                                                 self.prepareBeforeSend( docAfter, function( err, docAfter ){
                                                   self._sendErrorOnErr( err, next, function(){

                                                      self.afterPostAppend( params, body, options, doc, fullDoc, docAfter, fullDocAfter, function( err ){
                                                        self._sendErrorOnErr( err, next, function(){

                                                          self._res.json( 200, docAfter );

                                                        });
                                                      });
                                                   })
                                                 })
                                              } else { 

                                                self.afterPostAppend( params, body, options, doc, fullDoc, docAfter, fullDocAfter, function( err ){
                                                  self._sendErrorOnErr( err, next, function(){

                                                    self._res.send( 204, '' );

                                                  });
                                                });

                                              }

                                            // Local request: simply return the doc to the asking function
                                            } else {

                                              self.prepareBeforeSend( docAfter, function( err, docAfter ){
                                                self._sendErrorOnErr( err, next, function(){

                                                  self.afterPostAppend( params, body, options, doc, fullDoc, docAfter, fullDocAfter, function( err ){
                                                    self._sendErrorOnErr( err, next, function(){

                                                      next( null, docAfter, self.idProperty );

                                                    })
                                                  })

                                                })
                                              })
                                            }

                                          })
                                        });

                                      });
                                    })


                                  }) // err
                                }) // execPostDbAppend

                              } // granted


                            })
                          }) 

                        }) 
                      }) 

                    })
                  }) 

                }) // err
              }) // checkPermissionsPostAppend

            } // errors.length

          }) // err
        }) // self.validate

      }) // err
    }) // self.validate
  },

                        </code></pre>
					</section>
					<section>
						<h1>Convinced?</h1>
					</section>
				</section>

				<section>
					<h2>Where will I find async?</h2>
					<section>
						<h3>Producers</h3>
						<p class="fragment">User Interface</p>
						<p class="fragment">Models</p>
						<p class="fragment">Ajax</p>
						<p class="fragment">System Changes</p>
						<aside class="notes">
							UI - broadcast events<br/>
							Models - staet changes<br/>
							Ajax - complete/error<br/>
							System - wifi, location, battery changes<br/>
						</aside>
					</section>
					<section>
						<h3>Consumers</h3>
						<p class="fragment">Views</p>
						<p class="fragment">Controllers</p>
						<p class="fragment">Models</p>
						<aside class="notes">
							Views - update when state changes<br/>
							Controllers - direct action on events<br/>
							Models - change when other models change<br/>
						</aside>
					</section>
				</section>

				<section data-background-image="images/problem-solving.jpg?1323472010" class="bg-blur">
					<h2>Problems to Solve</h2>
				</section>

				<section data-background-image="images/49824-stages-of-rocket-launching-illustration.jpeg" class="bg-fade">
					<h2>Long Tasks One After Another</h2>

                    <img class="fragment" width="400px" height="300px" src="https://encrypted-tbn1.gstatic.com/images?q=tbn:ANd9GcS2hBhG_Y9prT3SyUfOf0atlzx9U2gc90L3Q8dTirJ7F8w9tB8_wsLNg7k"/>
					<aside class="notes">
						think ajax, file uploads
					</aside>
				</section>

				<section data-background-image="images/36542230.jpg" class="bg-blur">
					<h2>Long Tasks at once</h2>
					<aside class="notes">
						think ajax, file uploads
					</aside>
				</section>

				<section data-background-image="images/maxresdefault.jpg" class="bg-fade">
					<h2 class="border-light">Wait for tasks to finish</h2>
					<aside class="notes">
						after all ajax downloaded, display view
					</aside>
				</section>

				<section data-background-image="images/blockin.jpg" class="bg-slight-blur">
					<h2 class="shadow-light">Run Task without Blocking UI</h2>
					<aside class="notes">
						facebook detects dom changes in background (ie, react)
					</aside>
				</section>
                <section data-background-image="images/ui-block.jpg" data-background="black center" data-background-repeat="no-repeat"
                         data-background-size="contain">

                </section>
                <section data-background-image="images/54402087.jpg" class="bg-blur">
					<h2>Handling Errors</h2>
					<aside class="notes">
						handle errors that crop up in your application<br/>
						unhandled exceptions, 
					</aside>
				</section>
				<section data-background="white no-repeat contain center" data-background-image="images/workflow.jpeg" class="bg-blur"  >
					<h2>Dynamic or Complicated Workflows</h2>
					<aside class="notes">
						Complicated sequence of activities that have lots of branching and flows might need an event system
					</aside>
				</section>
				<section data-background="black no-repeat contain center" data-background-image="images/battery.png" class="dark bg-fade">
					<h2 class="shadow">Handling Triggered Events</h2>
					<aside class="notes">
						System events, UI events, etc.  Handle changes and react to them
					</aside>
				</section>

                <section data-background-image="images/Problems-solving.jpg"
                        data-background-size="contain" data-background="black center" data-background-repeat="no-repeat">

                </section>
				<section data-background-image="images/fractal_10.jpg" class="dark bg-fade">
					<h1>Patterns</h1>
					<p class="fragment" style="font-size:1.6em">aka, Great, what do I do with this knowledge?</p>
				</section>

				<section data-background="white">
					<h2>Callbacks</h2>
					<section data-background-image="images/keep-calm-and-call-me-later-1.png" data-background-size="contain" data-background="black center" data-background-repeat="no-repeat" class="bg-big-fade">

					</section>
					<section>
						<pre class="smaller"><code>
  readABigFile('filename.jpg', 
    function afterRead(error, file){
      console.log("Here's my file " + file);
    });
						</code></pre>
					</section>
					<section>
						<pre class="smaller"><code style="font-size:24px">
  readABigFile(new OnFileReadListener(){
     @Override
     public void onFileRead(File file){
        Log.d(TAG, "Read file " + file);
     }
     @Override
     public void onError(Exception e){
        Log.e(TAG, "Error reading file " + e);
     }
  });
						</code></pre>
					</section>
                    <section>
						<pre class="smaller"><code style="font-size:24px">
  readABigFile(file -> {
    Log.d(TAG, "Read file " + file);
  },
  ex -> {
    Log.e(TAG, "Error reading file " + e);
  });
                        </code></pre>
                        <aside class="notes">
                            Java 8 version

                        </aside>
                    </section>
                    <section data-background-image="images/Applause-Hands-dreamstime_m_2437415.jpg" class="hide-title" >

                    </section>

                    <section data-background="center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
                        <h5 class="positives">Positives</h5>
                        <p>Built-in</p>
						<aside class="notes">
							No 3rd party necessary
						</aside>
					</section>
					<section data-background="center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
						<h5>Positives</h5>
						<p>Easy to Read</p>
					</section>
					<section data-background="center" data-background-image="images/negative-reviews.jpg" class="bg-blur" data-background-repeat="no-repeat" data-background-size="cover">
						<h5>Negatives</h5>
						<p>Multiple calls quickly devolve</p>
						<aside class="notes">
							Nested calls
						</aside>
					</section>
                    <section data-background="center" data-background-image="images/negative-reviews.jpg" class="bg-blur" data-background-repeat="no-repeat" data-background-size="cover">
						<h5>Negatives</h5>
						<p>Can Stall</p>
						<aside class="notes">
							If you return and forget to call the callback, the code won't ever continue.  This is a fundamental difference from sequential programs.
						</aside>
					</section>
					<section>
						<h5>When to use</h5>
						<p>Simple use cases (most)</p>
						<aside class="notes">
							A lot of code doesn't need some higher level abstraction.  Don't go down a path of libraries and patterns if you don't need them.
						</aside>
					</section>
				</section>
				<section>
					<h2>Callback Libraries</h2>
					<section data-background-image="images/154558-004-DB68FE47.jpg" class="bg-blur">
						<p>Add coordination across callbacks</p>
					</section>
                    <section data-background="center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
						<h5>Positives</h5>
						<p>Consistent structure for calls</p>
					</section>
                    <section data-background="center" data-background-image="images/negative-reviews.jpg" class="bg-blur" data-background-repeat="no-repeat" data-background-size="cover">
						<h5>Negatives</h5>
						<p>Third Party Library</p>
					</section>
                    <section data-background="center" data-background-image="images/negative-reviews.jpg" class="bg-blur" data-background-repeat="no-repeat" data-background-size="cover">
						<h5>Negatives</h5>
						<p>Enforced Opinion</p>
					</section>
                    <section data-background="center" data-background-image="images/negative-reviews.jpg" class="bg-blur" data-background-repeat="no-repeat" data-background-size="cover">
						<h5>Negatives</h5>
						<p>Still inherit some problems of callbacks</p>
					</section>
                </section>

                <section>
                    <section>
                        <h2>javascript - async.js</h2>
                        <pre class="smaller"><code class="javascript" >
//nodejs style functions
function(err, data){

  //err is always first
  next(err);

  //if no error, call with null or undefined
  next(null, result);
}
                        </code></pre>
                    </section>
                    <section>
                        <h2>async.js - parallel</h2>
                        <pre class="smaller stretch"><code class="javascript" data-trim>
async.parallel([
  function downloadBlog(next){
    downloadBlogAComments(next);
  },
  function downloadUsers(next){
    downloadBlogAUsers(next);
  }
], function done(err, results){
    if (err) return alert(err);
    var blogWithComments = results[0];
    var users = results[1];
    display(blogWithComments, users);
});

//limit concurrent runners
async.parallelLimit([...], 5, cb);
                        </code></pre>
                    </section>
                    <section>
                        <h2>async.js - waterfall</h2>
                        <pre class="smaller stretch"><code class="javascript" data-trim>
async.waterfall([
  function download(next){
    getBlog(next);
  },
  function users(blog, next){
    getBlogUsers(blog, next);
  },
  function avatars(blog, users, next){
    getUserAvatars(function(err, avatars){
      next(err, blog, users, avatars);
    });
  }
], function done(err, blog, users, avatars){
    if (err) return alert(err);
    display(blog, users, avatars);
});
                        </code></pre>
                    </section>
                    <section>
                        <h2>async.js - more</h2>
                       <ul style="font-size: 1.5em">
                           <li>map</li>
                           <li>filter</li>
                           <li>each</li>
                           <li>eachSeries</li>
                           <li>[much more]</li>
                       </ul>
                    </section>
                </section>
                <section>
                    <h2>Android - Bolts</h2>
                    <pre class="smaller stretch"><code class="Java" style="font-size: 0.9em; line-height: 1.5em">
saveAsync(obj).continueWith(new Continuation&lt;ParseObject, Void>() {
  public Void then(Task&lt;ParseObject> task) throws Exception {
    if (task.isCancelled()) {
      // the save was cancelled.
    } else if (task.isFaulted()) {
      // the save failed.
      Exception error = task.getError()
    } else {
      // the object was saved successfully.
      ParseObject object = task.getResult();
    }
    return null;
  }
});
                       </code></pre>
                </section>
                <section>
                    <h2>Android - Bolts: Series</h2>
                    <pre class="smallest stretch"><code data-trim>
ParseQuery&lt;ParseObject> query = ParseQuery.getQuery("Comments");
query.whereEqualTo("post", 123);

findAsync(query).continueWithTask(new Continuation&lt;List&lt;ParseObject>, Task&lt;Void>>() {
  public Task&lt;Void> then(Task&lt;List&lt;ParseObject>> results) throws Exception {

    // Create a trivial completed task as a base case.
    Task&lt;Void> task = Task.forResult(null);
    for (final ParseObject result : results) {

      // For each item, extend the task with a function to delete the item.
      task = task.continueWithTask(new Continuation&lt;Void, Task&lt;Void>>() {
        public Task&lt;Void> then(Task&lt;Void> ignored) throws Exception {
          // Return a task that will be marked as completed when the delete is finished.
          return deleteAsync(result);
        }
      });
    }
    return task;
  }
}).continueWith(new Continuation&lt;Void, Void>() {
  public Void then(Task&lt;Void> ignored) throws Exception {
    // Every comment was deleted.
    return null;
  }
});
                    </code></pre>
                    <aside class="notes">
                        https://github.com/BoltsFramework/Bolts-Android
                    </aside>
                </section>

				<section data-background="white">
					<section data-background-image="images/puppet-master.png" class="bg-slight-blur">
                        <h2>Delegation Pattern</h2>
						<p>Hand off control to 1 other actor</p>
						<aside class="notes">
						Android: think, registering activity callback when an action happens in a fragment (clicked on button)
						</aside>
					</section>
					<section>
                        <h2>Delegation Pattern</h2>
                        <pre class="smallest stretch" ><code data-trim>
public interface FragmentListener {
  public void buttonClicked();
  public boolean shouldAcceptClick();
  public void valueChanged(int value);
}

public GameViewActivity extends Activity implements FragmentListener {
   ...

  @Override
  public boolean shouldAcceptClick() {
    return isAdmin && isFormFilledOut;
  }

  @Override
  public void buttonClicked(){
    startActivity(...);
  }

  @Override
  public void valueChanged(int value){
    this.value = value;
    this.isFormFilledOut = (value != 0);
  }
}
                        </code></pre>
					</section>

					<section>
                        <h2>Delegation Pattern</h2>
                        <pre class="smallest stretch" ><code data-trim>
public GameFragment extends Fragment {
  private FragmentListener listener;
  ...

  @Override
  public void onAttach(Activity activity) {
    super.onAttach(activity);
    try {
        listener = (FragmentListener) activity;
    } catch (ClassCastException e) {
        throw new ClassCastException(activity.toString()
                            + " must implement FragmentListener");
    }
  }
  @Override
  public void onClick(View v) {
    listener.buttonClicked();
  }

  ...
}
                        </code></pre>
					</section>
                    <section data-background="center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
						<h5>Positives</h5>
						<p>Two-way Control</p>
                        <aside class="notes">
                            Not just subscribing - can send data, request data, etc
                        </aside>
					</section>
                    <section data-background="center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
						<h5>Positives</h5>
						<p>Very Clear API (interface)</p>
                        <aside class="notes">
                            Self documenting.  Advantage over some other patterns
                        </aside>
					</section>
                    <section data-background="center" data-background-image="images/negative-reviews.jpg" class="bg-blur" data-background-repeat="no-repeat" data-background-size="cover">
						<h5>Negatives</h5>
						<p>Switching Listener</p>
					</section>
					<section>
						<h5>When to use</h5>
						<p class="fragment">View 1-to-1 with "worker"</p>
						<p class="fragment">Service "instance"</p>

                        <aside class="notes">
                            UI Component - if your component has one "presenter" or driver, it can use a delegate pattern to communciate effectively back and forth<br/>
                            Service Instance - you CAN use this pattern to allow works to subscribe to callbacks when things download/succeed.  See iOS NSURLSession handlers on the original class<br/>
                            Coupling - also applicable if you have a service that is ONLY ever going to be for one view<br/>
                        </aside>
					</section>
				</section>
				<section>
                    <section data-background-image="images/Observer.png" class="bg-fade">
                        <h2 class="border-light">Observer Pattern</h2>
                        <p  class="border-light">"Observe" an object's state changes</p>

                        <aside class="notes">
                            Observers register themselves with the subject.<br/>
                            Subject maintains the list of its  dependents (Observers), and it broadcast notification  to all its dependents when it’s state changes.<br/>
                            Observers de-register explicitly when they no more want to be notified.<br/>
                        </aside>
                    </section>
                    <section>
                        <h2>Backbone.js</h2>
                        <pre class="smaller stretch"><code>
 //view
 initialize: function() {
   this.listenTo(this.model, 'change', this.render);
   this.listenTo(this.model, 'destroy', this.remove);
 },
                        </code></pre>
                    </section>

                    <section>
                        <h2>Adding Observability</h2>
                        <pre class="smaller stretch"><code>
 var EventEmitter = require('events').EventEmitter;
 var util = require('util');

 var MyModule = {};
 EventEmitter.call(MyModule);
 util.inherits(MyModule, EventEmitter);

 MyModule.set = function(elems){
   this._set(elems);
   this.emit('change', elems);
 }
 ...

 var myModule = require('modules/mymodule');
 myModule.on('change', function(){...
                        </code></pre>
                        <aside class="notes">
                            EventEmitter is a NodeJS lib
                        </aside>
                    </section>
                    <section>
                        <h2>Android</h2>
                        <pre class="smaller"><code>
 textField.addTextChangedListener(this);
 @Override
 public void afterTextChanged(Editable s) {
    String value = s.getText().toString();
 }
                        </code></pre>
                    </section>
                    <section data-background="center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
                        <h5>Positives</h5>
                        <p>Loose Coupling</p>
                        <aside class="notes">
                            Publisher doesn't know who is listening
                        </aside>
                    </section>
                    <section data-background="center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
                        <h5>Positives</h5>
                        <p>Specific Object of Interest</p>
                        <aside class="notes">
                            Not just willy-nilly listening to events.  Most of the time this is great, but sometimes you need to know a "new object" got created.
                        </aside>
                    </section>
                    <section>
                        <h5>Positives</h5>
                        <p>One or Many Subscribers</p>
                    </section>
                    <section data-background="center" data-background-image="images/negative-reviews.jpg" class="bg-blur" data-background-repeat="no-repeat" data-background-size="cover">
                        <h5>Negatives</h5>
                        <p>Memory Loops</p>
                        <aside class="notes">
                            View might disappear, but still registered for events
                        </aside>
                    </section>
                    <section data-background="center" data-background-image="images/negative-reviews.jpg" class="bg-blur" data-background-repeat="no-repeat" data-background-size="cover">
                        <h5>Negatives</h5>
                        <p>Can Only Register to Observe Future</p>
                        <aside class="notes">
                            You usually only hear events, so you need to handle synchronously, and then also in your async block
                        </aside>
                    </section>
                    <section data-background="center" data-background-image="images/negative-reviews.jpg" class="bg-blur" data-background-repeat="no-repeat" data-background-size="cover">
                        <h5>Negatives</h5>
                        <p>Often String-based Event Names</p>
                        <aside class="notes">
                            Can make intent of the api a little tough to follow.  There's no self-documenting structure in many cases.
                        </aside>
                    </section>
                    <section>
                        <h5>When to Use</h5>
                        <p class="fragment">View/Model Changes</p>
                        <p class="fragment">Backbone.js/Frameworks</p>
                        <p class="fragment">DOM</p>
                        <p class="fragment">Lots of other places</p>
                    </section>
				</section>
				<section data-background="white">
                    <section>
                        <h2>Promises</h2>
                    </section>
                    <section>
                        <p>Simplified model of async</p>
                        <aside class="notes">
                            NOTE: has a compliant spec
                            Go into "what it is"
                        </aside>
                    </section>
                    <section>
                        <p>OPTIONAL: Multi-threaded</p>
                    </section>
                    <section data-background="center" data-background-image="images/wonka.jpg" data-background-repeat="no-repeat" data-background-size="contain">
                    </section>
                    <section data-background="center" data-background-image="images/wonka.jpg" class="bg-fade" data-background-repeat="no-repeat" data-background-size="contain">
                        <p class="border-light ">Object that will <i>always</i> either resolve or reject</p>
                    </section>
                    <section>
                        <p>A promise must be in one of three states:</p>
                        <ul style="font-size:1.4em">
                            <li>pending</li>
                            <li>fulfilled</li>
                            <li>rejected</li>
                        </ul>
                    </section>
                    <section data-background-image="images/6929697914_0fd3bd4457_b.jpg" data-background-size="contain">
                        <aside class="notes">
                            Immutable
                        </aside>
                    </section>
                    <section>
                        <h2>Pyramid of Doom</h2>
                        <pre><code>
step1(function (value1) {
  step2(value1, function(value2)
    step3(value2, function(value3) {
      step4(value3, function(value4) {
        // Do something with value4
      });
    });
  });
});
                        </code></pre>
                    </section>
                    <section data-background-image="images/Indiana-Jones-and-the-Temple-of-Doom-Mola-Ram-Amrish-Puri-heart.png" data-background-size="contain">

                    </section>
                    <section>
                        <h2>Q - javascript</h2>
                        <pre class="stretch"><code>
  Q.fcall(promisedStep1)
  .then(promisedStep2)
  .then(promisedStep3)
  .then(promisedStep4)
  .then(function (value4) {
    //Do something with value4
  })
  .catch(function (error) {
    //Handle errors from ANY above steps
  })
  .done();
                        </code></pre>
                        <aside class="notes">
                            Ending a promise chain makes sure that, if an error doesn’t get handled before the end, it will get rethrown and reported.
                        </aside>
                    </section>
                    <section>
                        <h2>What's in a promise?</h2>
                        <pre class="stretch"><code class="javascript" data-trim>
 //create
 var deferred = Q.defer();

 FS.readFile("foo.txt", "utf-8",
   function (error, text) {
     if (error) {
        deferred.reject(new Error(error));
     } else {
        deferred.resolve(text);
     }
   });

 //return the promise (not the result)
 return deferred.promise;
                        </code></pre>
                    </section>
                    <section>
                        <h2>Node-ify</h2>
                        <pre><code class="javascript">
 return Q.nfcall(FS.readFile,
                 "foo.txt",
                 "utf-8");
                        </code></pre>
                    </section>
                    <section>
                        <h2>Return types</h2>
                        <pre class="stretch smaller"><code class="javascript" data-trim>
 function authenticate() {
   return getUsername()
    .then(function (username) {
      //naive cache
      var cachedUser = cache[username];
      // --> returns synchronous params
      return [username, user];
    })
    .spread(function (username, user) {
       // --> returns synchronous user
       if (user) return user;

       // --> returns promise
       return getUser(username);
    })
    .then(function (user) {
       ...
                        </code></pre>
                        <aside class="notes">
                            Important because it lets you chain.  One time you return a promise, another it's a direct object
                        </aside>
                    </section>
                    <section>
                        <h2>Concurrent</h2>
                        <pre><code class="java">
return Q.all([
    eventualAdd(2, 2),
    eventualAdd(10, 20)
]);
                        </code></pre>
                        <aside class="notes">
                            Works with runnable, callable, future
                        </aside>
                    </section>
                    <section>
                        <h1>Android</h1>
                        <h2>JDeferred</h2>
                        <aside class="notes">
                            NOTE: not Promise/A+ spec compliant
                        </aside>
                    </section>
                    <section>
                        <h2>Promise callbacks</h2>
                        <pre><code class="java">
  .then(…)
  .done(…)
  .fail(…)
  .progress(…)
  .always(…)
                        </code></pre>
                        <aside class="notes">
                            Works with runnable, callable, future
                        </aside>
                    </section>
                    <section>
                        <h2>Combined callbacks</h2>
                        <pre><code class="java">
  .when(p1, p2, p3, …).then(…)
                        </code></pre>
                        <aside class="notes">
                            Run multiple promises concurrently, wait for finish
                        </aside>
                    </section>
                    <section>
                        <h2>Load from DB or WEB</h2>
                        <pre class="stretch smallest"><code class="java" data-trim>

Promise promise = blogDAO.loadFromDB(blogId);

promise.then(new DonePipe&ltBlog, Throwable, Void, Void>() {
  @Override
  public Promise&ltBlog, Throwable, Void> onDone(Blog blog) {
    if (blog != null) {
       return new DeferredObject&ltBlog, Throwable, Void>()
                        .resolve(blog);
    } else {
       return blogRestService.loadBlog(blogId);
    }
  }
})
.done(new DoneCallback&ltBlog>() {
  @Override
  public void onDone(Blog rejection) {
    //display blog
  }
})
.fail(new FailCallback&ltThrowable>() {
  @Override
  public void onFail(Throwable exception) {
    //handles any thrown exceptions
  }
});

                        </code></pre>
                    </section>
                    <section data-background-image="images/mckayladisappointed.jpg">

                    </section>

                    <section>
                        <h2>LAMBDAS!</h2>
                        <pre class="stretch smaller"><code class="java" data-trim>

return blogDAO.loadFromDB(blogId)
 .then( (blog, throwable) -> {
   if (blog != null)
     //resolve immediate
     return new DeferredObject&ltBlog, Throwable, Void>()
                        .resolve(blog);
   else
     //resolve later
     return blogRestService.loadBlog(blogId);
 })
 .done(blog ->
   //display blog
 })
 .fail(exception -> {
   //handles any thrown exceptions
 });

                        </code></pre>
                    </section>
                    <section data-background="center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
                        <h5>Positives</h5>
                        <p>Mimics Synchronous Code</p>
                        <aside class="notes">
                            Looks like synchronous code
                        </aside>
                    </section>
                    <section data-background="center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
                        <h5>Positives</h5>
                        <p>Error Handling</p>
                        <aside class="notes">
                            Easily bubble up typed errors, catch uncaught exceptions.
                            <br/><br/>
                            One gotcha - syntax can take a second error handler.  You should still have a good strategy for sending up typed errors or handling them as they occur.  Treat it like Try/Catch rules.
                        </aside>
                    </section>
                    <section data-background="center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
                        <h5>Positives</h5>
                        <p>All Paths Exit</p>
                        <aside class="notes">
                            You can't screw up and get stuck.  It will always go to the next block
                        </aside>
                    </section>
                    <section data-background="center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
                        <h5>Positives</h5>
                        <p>Resolve Immediately</p>
                        <aside class="notes">
                            Return state immediately and still go to the callbacks
                        </aside>
                    </section>
                    <section data-background="center" data-background-image="images/negative-reviews.jpg" class="bg-blur" data-background-repeat="no-repeat" data-background-size="cover">
                        <h5>Negatives</h5>
                        <p>External Library</p>
                        <aside class="notes">
                            Libs implement different versions of what it means to have "Promises". Luckily, most things are converting to follow the Promises/A standard.
                        </aside>
                    </section>
                    <section data-background="center" data-background-image="images/negative-reviews.jpg" class="bg-blur" data-background-repeat="no-repeat" data-background-size="cover">
                        <h5>Negatives</h5>
                        <p>Can Discourage Testing "Units"</p>
                        <aside class="notes">
                            In practice, it feels a little common to put your code in a promise block and deal with it right there.  This isn't a science, just an observed behavior.
                        </aside>
                    </section>
                    <section data-background="center" data-background-image="images/negative-reviews.jpg" class="bg-blur" data-background-repeat="no-repeat" data-background-size="cover">
                        <h5>Negatives</h5>
                        <p>Hard to De-register</p>
                        <aside class="notes">
                            In some of the libraries, it can be hard to cancel the promises if your view goes out of scope.
                        </aside>
                    </section>
                    <section data-background="center" data-background-image="images/negative-reviews.jpg" class="bg-blur" data-background-repeat="no-repeat" data-background-size="cover">
                        <h5>Negatives</h5>
                        <p>Hard to Construct Promises Initially</p>
                        <aside class="notes">
                            For some reason, the behavior of promises can be a little confusing to write for yourself initially
                        </aside>
                    </section>
                    <section>
                        <h5>When to Use</h5>
                        <p class="fragment">Backend Ajax -> DB Storage</p>
                        <p class="fragment">Coordinated Async Calls </p>
                        <p class="fragment">When It's Available</p>
                        <aside class="notes">
                            JS - Built into es6<br/>
                            JS - Built into Chrome 32, Opera 19 & Firefox 29 (small polyfill exists)<br/>
                            Android - when you can use retrolamda and RxJava is too much for you<br/>
                        </aside>
                    </section>
				</section>
				<section>
                    <section>
                        <h2>Message Bus</h2>
                        Central service for sending and receiving messages
                    </section>
                    <section>
                    	<h2>Android - Otto</h2>
                        <pre class="smaller "><code class="java">
bus.post(new AnswerEvent(42));

...

@Subscribe
public void answerAvailable(AnswerEvent event){
  // TODO: React to the event somehow!
}
                        </code></pre>
                    </section>
                    <section>
                        <h2>Javascript - postal.js</h2>
                        <pre class="smaller "><code class="javascript">
var subscription = postal.subscribe({
  channel: "orders",
  topic: "item.add",
  callback: function(data, envelope) {
     //handle item added
  }
});
                        </code></pre>
                        <aside class="notes">
                            data has the passed through data<br/>
                            envelope has sent timestamp, channel, etc
                        </aside>
                    </section>
                    <section>
                        <h2>Javascript - postal.js</h2>
                        <pre class="smaller "><code class="javascript">
postal.publish({
  channel: "orders",
  topic: "item.add",
  data: {
    sku: "AZDTF4346",
    qty: 21
  }
});
                        </code></pre>
                        <aside class="notes">
                            data has the passed through data
                            envelope has sent timestamp, channel, etc
                        </aside>
                    </section>
                    <section data-background="center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
                        <h5>Positives</h5>
                        <p>Completely De-Coupled</p>
                        <aside class="notes">
                            Neither receivers or publishers know about each other

                            Can be a nice design, and the alure of completely decoupled views/models/controllers excites a certain type of dev
                        </aside>
                    </section>
                    <section data-background="center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
                        <h5>Positives</h5>
                        <p>Views/models/services work independently</p>
                        <aside class="notes">
                            Makes it so services can come and go, and anyone can subscribe to events and register themselves
                        </aside>
                    </section>
                    <section data-background="center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
                        <h5>Positives</h5>
                        <p>Components can self-register</p>
                        <aside class="notes">
                            You can have an app boot-up that skips the 1 by 1 registration of your app services; they just self register
                        </aside>
                    </section>

                    <section data-background="center" data-background-image="images/negative-reviews.jpg" class="bg-blur" data-background-repeat="no-repeat" data-background-size="cover">
                        <h5>Negatives</h5>
                        <p>Hard to trace publish origins</p>
                        <aside class="notes">
                            Searching through the codebase for where events come from can be challenging.  Same with refactoring.
                            <br/><br/>
                            Not self-documenting
                        </aside>
                    </section>
                    <section data-background="center" data-background-image="images/negative-reviews.jpg" class="bg-blur" data-background-repeat="no-repeat" data-background-size="cover">
                        <h5>Negatives</h5>
                        <p>Needs developer limits</p>
                        <aside class="notes">
                            Avoid "pub" to "sub"..<br/>
                            Events shouldn't really publish other events<br/>
                            This starts too much of a cascading SOA without a central mechanism to see the flows<br/>
                            You don't want to initiate async events on a hub just to load data.  Only do this for things that you don't care if they're not going to return until later
                        </aside>
                    </section>
                    <section data-background="center" data-background-image="images/negative-reviews.jpg" class="bg-blur" data-background-repeat="no-repeat" data-background-size="cover">
                        <h5>Negatives</h5>
                        <p>Stateless</p>
                        <aside class="notes">
                            Can get confused for something that "should" have state, and if it's your only way to get the state, you're going to start "asking" things of the bus
                        </aside>
                    </section>
                    <section data-background="center" data-background-image="images/negative-reviews.jpg" class="bg-blur" data-background-repeat="no-repeat" data-background-size="cover">
                        <h5>Negatives</h5>
                        <p>Should be a "part" of your architecture, not the only pattern</p>
                        <aside class="notes">
                            Combine this with the observer.  Once you want updates for a certain object, you should be listening to that object.<br/>
                        	Not meant for fine-grained state<br/>
                        	If you pub to sub, might get events initiated by something else
                            <br/><br/>
                            If your event can be broadcast for multiple objects, gets noisy (think blog:updated.  must filter each one by the blog id)
                            <br/><br/>
                            Think about posting to the bus about "creating" a new blog.  If you care about the result, you need to subscribe to the "BlogCreated" event, and then figure out if it's yours, or something else.
                        </aside>
                    </section>
                    <section>
                        <h5>When to use</h5>
                        <p class="fragment">System-wide events</p>
                        <p class="fragment">Inter-module communication</p>
                        <p class="fragment">Want to handle EVERY event</p>
                        <p class="fragment">Library   allows easy filtering</p>
                        <aside class="notes">
                            System-wide events: think battery, network error occurred, user logged out, user logged in, startup device, app resumed, etc<br/>
                            Inter-Module Communication: communicate across views so they're not coupled, across libraries<br/>
                            Every event: don't want to constantly filter on everything ideally.  If you have a "subject", better to emit events about that subject (Observer)<br/>
                            Easily filtered: don't want a tough lib to handle getting out the bad messages<br/>
                        </aside>
                    </section>
				</section>
				<section  data-background="white center" class="bg-blur" data-background-image="images/yield_sign_page.png"
                        data-background-size="contain" data-background-repeat="no-repeat">
                    <h2>Generators</h2>
                    <p>Keywords built into language to handle async</p>
<pre><code data-trim>
yield, await, async
</code></pre>
                    <aside class="notes">
                        Built-in to EmcaScript 6 (ES6), .NET
                        <br/><br/>
                        Also sometimes called coroutines.
                        <br/><br/>
                        Generators are "shallow" coroutines that return promises
                        <br/><br/>
                        But coroutines would allow yielding in nested functions, which could modify your current objects without you knowing it
                        http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/
                        <br/><br/>
                        //promises with generators
                        http://blogs.atlassian.com/2013/11/harmony-generators-and-promises-for-node-js-async-fun-and-profit/

                    </aside>
                </section>

                <section data-background-image="images/superstreetfighter2.jpg" class="bg-fade">
                    <h2 class="border-light">Reactive Programming</h2>
                    <aside class="notes">
                        Combos of all of the above
                        <br/><br/>
                        Too much for this presentation, but includes promises, observer pattern, chaining, and other functional programming
                        <br/><br/>
                        about how the learning curve feels
                    </aside>
                </section>

                <section data-background="white">
                    <section class=" bg-fade" data-background-image="images/Copyoferase.jpg">
                        <h2 class="shadow ">Ok, how do I use this?</h2>
                    </section>
                    <section>
                        <h2>Services</h2>
                        <p>Promises/Callback Coordinators</p>
                        <p>Message Bus</p>
                        <aside class="notes">
                            Use promises or coordinators to have your db and rest calls coordinated
                            <br/><br/>
                            Message bus for significant events
                            <br/><br/>
                            Ignore callbacks if out of scope
                        </aside>
                    </section>
                    <section>
                        <h2>Models</h2>
                        <p>Observable</p>
                        <p>Promises</p>

                        <aside class="notes">
                            Publish events when things change (to listeners of one model)
                            <br/>
                            If your model has events itself, use promises or more observables to allow CRUD

                        </aside>
                    </section>
                    <section>
                        <h2>Views/Controllers</h2>
                        <p>Observable</p>
                        <p>Observer</p>
                        <p>Message Bus</p>
                        <aside class="notes">
                            Observe model state
                            <br/>
                            Publish view events to subscribers
                            <br/>
                            Publish user events across views with message bus
                            <br/>
                            Interact directly with service layer
                        </aside>
                    </section>

                    <section>
                        <h2>System Services</h2>
                        <p>Observable</p>
                        <p>Message Bus</p>
                        <aside class="notes">
                            Either directly observer, or get and broadcast with a service
                        </aside>
                    </section>
                    </section>
                </section>

				<section data-background="white">
					<section class="bg-fade" data-background-image="images/caseybluefletch.jpg">
                        <h1 class="border-light">Tips/Tricks</h1>
					</section>
					<section>
						<h2>2 deep!</h2>
                        <aside class="notes">
                            Refactor as you write and notice code nesting
                        </aside>
					</section>
					<section data-background-image="images/karate-snap-wood.jpg" data-background-size="cover" data-background-repeat="no-repeat" class="bg-fade">
						<h2>Aim for vertical</h2>
						<aside class="notes">
							Karate chop
                        </aside>
					</section>
					<section data-background-image="images/polls_600px_No_sign.svg_0345_947560_answer_2_xlarge.png" data-background-size="contain">
                        <h2>Avoid Diagonal</h2>
					</section>
					<section>
                        <h2>Focus on <span style="-webkit-filter: blur(4px);">Readability</span></h2>
					</section>
                    <section>
                        <h2>De-register when Views Disappear</h2>
                        <aside class="notes">
                            If you reference views/elements that might be gone when your callback runs, you may end up killing your app.  This is true of almost every async pattern and is something you need to think about.
                            <br/>
                            Backbone handles this for you by inversing the ownership of the model events so that the view holds the registration and will kill them off on destroy.
                        </aside>
                    </section>
					<section data-background-image="images/clean_code.png" data-background-size="contain"
                            class="bg-blur">
						<h2>Write testable functions</h2>
                        <p class="fragment">Then add coordination</p>
						<aside class="notes">
							This helps to think in terms of little units, as well as testing
						</aside>
					</section>
					<section data-background-image="images/wheel.png" data-background-repeat="no-repeat" class="bg-slight-blur">
						<h2>Don't be clever.</h2>
                        <aside class="notes">
                            Use patterns when you need them!!!
                            <br/>
                            Use libraries that exist - you'll end up breaking something
                            <br/>
                            If you invent something, you will probably be the only one that understands it.
                        </aside>
					</section>
				</section>
                <section>
                    <h2>Questions</h2>
                    <br/><br/>
                    <footer><a href="https://github.com/blakebyrnes/async-programming-presentation">https://github.com/blakebyrnes/async-programming-presentation</a></footer>
                </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: false,
				progress: true,
				history: true,
				center: true,
				slideNumber: false,

				transition: 'convex', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
            Reveal.configure({
                keyboard: {
                    13: 'next', // go to the next slide when the ENTER key is pressed
                    39 : 'next'
                }
            });
		</script>

	</body>
</html>
