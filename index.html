<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Asynchronous Programming Techniques</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">
		<link rel="stylesheet" href="css/preso.css" >

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
        <style>
            @-webkit-keyframes blur-anim {
                from { -webkit-filter: blur(0); }
                to { -webkit-filter: blur(6px); }
            }
            @-webkit-keyframes opac-anim {
                from { -webkit-filter: opacity(100%); }
                to { -webkit-filter: opacity(20%); }
            }

            @-webkit-keyframes fade-out {
                from { -webkit-filter: opacity(100%); }
                to { -webkit-filter: opacity(5%); }
            }
            @-webkit-keyframes opac-anim-60 {
                from { -webkit-filter: opacity(100%); }
                to { -webkit-filter: opacity(60%); }
            }
            @-webkit-keyframes fade-in {
                 from { -webkit-filter: opacity(0%); }
                 to { -webkit-filter: opacity(100%); }
             }
             /*-webkit-animation: blur-anim 2s linear, opac-anim 2s linear; -webkit-animation-direction: alternate;*/
            .backgrounds .bg-blur {
                -webkit-filter: blur(6px) opacity(20%);
            }
            .backgrounds .bg-slight-blur {
                -webkit-filter: blur(2px) opacity(50%);
            }

            .backgrounds .bg-fade {
                -webkit-filter: blur(1px) opacity(60%);
            }
            .backgrounds .bg-slight-fade {
                -webkit-filter: blur(1px) opacity(80%);
            }
            .backgrounds .bg-big-fade {
                -webkit-filter: blur(1px) opacity(20%);
            }
            !h2 ~ section.hide-title.present,section.hide-title.hide-title.present + h1 {
                display: none !important;
            }

            .present > * > .fade-on-display {
                -webkit-animation: fade-out 3s forwards ease-in-out;
            }
            h2.shadow,h3.shadow {
                text-shadow: 2px 4px 3px rgba(0,0,0,0.3);
            }
            h2.shadow-light {
                 text-shadow: 4px 0 4px rgba(255,255,255,0.8);
             }
            h2.border-light,p.border-light {
                  text-shadow: 0 2px  rgba(235,235,235,0.8);
              }
            .reveal .dark h3,.reveal .dark h2, .reveal .dark p,.reveal .dark h1, .reveal .dark h5 {
                color: #fff;
            }
            p {
                font-size: 1.4em !important;
            }
            div.shaded {
                background:rgba(255,255,255,0.9);
                padding:10px;
            }
            .shaded {
                background:rgba(255,255,255,0.9);
            }
            .shaded-8 {
                background:rgba(255,255,255,0.8);
            }
        </style>
        <!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Async Programming</h1>
					<h3>Rope ladders and quicksand shoes</h3>
					<p>
						<small>Created by <a href="http://bluefletch.com">Blake Byrnes</a> / <a href="http://twitter.com/blakebyrnes">@blakebyrnes</a></small>
					</p>
                    <aside class="notes">
                        Briefly - what will this be about?
                    </aside>
				</section>

				<section class="bg-big-fade" data-background-image="images/caseybluefletch.jpg">
					<h2>Who am I?</h2>
                    <h3>Blake Byrnes</h3>
					<h4>
						CTO of BlueFletch Mobile
					</h4>
					<q>
						I work with: <em>iOS, Android, nodejs, html5/ionic/cordova, AWS and sometimes .NET, backend Java</em>
					</q>
				</section>

                <section class="dark" data-background="white center" data-background-image="images/1d5741309ea65303b436ce736f0acca10c88b06552b42184650cb8b4119e036b.jpg" data-background-size="contain"
                         data-background-repeat="no-repeat">
                    <h2 class="shadow">Why are you here?</h2>
                    <aside class="notes">
                        Poll group - why are you here
                        <br/>- Learning new skills?
                        <br/>- Had issues with async
                        <br/>- Best presentation available
                        <br/>- Presenter seemed a little off kilter from the intro
                    </aside>
                </section>

                <section data-background-image="images/Napoleon-Dynamite-skills-gif.gif" data-background-size="contain" data-background="white center" data-background-repeat="no-repeat"
                        >
                    <aside class="notes">
                        All know skills are important, what are yours?
                        <br/>Poll group - language skills
                        <br/>-Java
                        <br/>-Javascript
                        <br/>.Net
                        <br/>Other
                    </aside>
                </section>

				<!-- -->
				<section>
					 <section  class="bg-blur" data-background-image="images/nm5.jpg">
                         <h2>Why I think we're here</h2>
                         <aside class="notes">
                             Shifts going on in industry.  Building more API-based back-ends, rich front-ends with multiple clients
                         </aside>
					</section>
                    <section class="bg-blur" data-background-image="images/rise_of_mobile-1280x880.jpg" >
                        <h1>Rise of Mobile</h1>
                        <aside class="notes">
                            Poll audience on how many are doing mobile apps, or interested
                            <br/>
                            Inherently asynchronous env (threading no longer your concern like backend)
                        </aside>
                    </section>
                    <section class="bg-blur" data-background-image="images/WB0977873.png">
                        <h1>Single Page Apps</h1>
                        <aside class="notes">
                            Angular, Backbone, ExtJS (enterprise), PhoneGap (Ionic)
                            <br/><br/>
                            Ask how many people are working with one of these
                        </aside>
                    </section>

                    <section class="bg-blur" data-background-image="images/node-js.jpg">
                        <h1>Server Side Javascript</h1>
                        <aside class="notes">

                            Javascript is eating the world
                        </aside>
                    </section>

                    <section>
                        <h3>But I already know async...</h3>
                       	<pre ><code data-trim style="font-size:40px !important">
$("#button").click(function(e){
  console.log("handle async.");
});
                        </code></pre>
                        <aside class="notes">
                            Client side - handle events
                        </aside>
                    </section>

                    <section data-background-image="images/EasyButton.jpg" data-background-size="contain" data-background-repeat="no-repeat" data-background="white center">
                        <aside class="notes">
                            Some of you are saying, I went to the wrong class. Shit
                        </aside>
                    </section>
                    <section class="dark" data-background-image="images/4.jpg">
                        <h2>It Gets Complicated Quickly</h2>
                        <aside class="notes">
                            Gets a lot harder when you start orchestrating multiple events
                        </aside>
                     </section>

                    <section>
                        <h2>Thinking asynchronously is hard...</h2>
                        <h2 class="fragment">But cheer up, Eventually you'll get it!</h2>
                    </section>
                    <section data-background-image="images/Image-53.png">
                    </section>
                    <section>
                        <h2>Eventually you'll get it...</h2>
                    </section>
                    <section data-background-transition="slide" data-background-size="80%" data-background-image="images/73d71fab45496a6671d670687eb359dd6293817166ddb699f7e1fb44358bad26.jpg">

                    </section>
					<section data-theme="black">
						<h2>You must learn it!</h2>
                        <img src="images/patience-learn-you-must.jpg"/>
					</section>
					<section>
						<h2>Real Email</h2>
						<p>"I am working on a Appcelerator project for android and I see that the AJAX call  is not synchronous..   And because of this, my function (sic) populating the UI from the AJAX response is failing."</p>
                        <aside class="notes">
                            Is this familiar for anyone?
                        </aside>
					</section>
					<section>
						<p>Pseudo-code</p>
						<pre class=" smallest"><code class="javascript">
plugs.prototype.httpReq = function() {
  ...

  xhr.onload = function(e) {
    dataObj = JSON.parse(xhr.responseText)
  };

  xhr.open("GET", url,false);
  // Send the request.
  xhr.send();
};

plugs.prototype.populateData = function(){
  for(var i=0;i dataObj.length;i++) { //CRASH (dataObj is undefined)  
...

plugs.httpReq();
plugs.populateData();
						</code></pre>
						<aside class="notes">
							Developer didn't understand that the asynchronous code would perform out of order from the sequential order on the screen
						</aside>

					</section>
					<section>
						<h2><strong>Don't let this happen to you</strong></h2>
					</section>
                    <section data-background="black">
                        <img src="images/You_7900a8_1204562.jpg"/>
                    </section>
					<section class="bg-fade" data-background-image="images/toolbelt.jpg">
						<h2 class="shaded-8">Add to your toolbelt</h2>
					</section>
				</section>
				<section>
					<section data-background-image="images/running-man-05-g.jpg" class="bg-slight-blur">
                        <h2 class="shaded-8">What is async?</h2>
                        <div class="shaded-8">
                            <h4>Code that doesn't wait!</h4>
                            <p style="font-size: 1.5em">Will execute later</p>
                        </div>
                        <!-- running man picture -->
						<aside class="notes">
							Important to talk about how it doesn't block.  Implication is that it can get more out of the CPU where the code is running
						</aside>
					</section>
                    <section data-background="white">
                        <h2 style="color:#292f33">Your brain is an asynchronous machine</h2>
                        <p style="color:#2b7bb9">#devnexus #asyncprogramming #omgenius</p>
                        <aside class="notes">
                             Ever thought as you were leaving, "Remember to lock the door", then you did a bunch of other stuff,
                            and then you finally got to the door, and remembered to lock it.  Kinda like that.
                        </aside>
                    </section>
					<section>
                        <h2>1, 2, 3</h2>
					    <pre class="smaller"><code data-trim>
console.log(1);

$("#button").click();

console.log(2);

console.log(3);

//1
//click
//2
//3
						</code></pre>
					</section>
					<section>
                        <h2>Becomes 1, 3, 2</h2>
					    <pre><code data-trim>
console.log(1);

$("#button").click(function(e){
  console.log(2);
});

console.log(3);

//1
//3
//click: 2
						</code></pre>
					</section>
                    <section>
						<p>Don't be Greedy</p>
						<pre class=""><code class="javascript">
while (forever == true) {
 runSlowThingsLikeABoss();
}

manThisAppSucks();
                        </code></pre>
						<aside class="notes">
                            Brings me to my next point.<br/>
                            Async built around not "blocking" so that the UI can refresh.
						</aside>

                    </section>
                    <section>
						<p>Share the CPU</p>
						<pre class=""><code class="java">
while (userHasntClicked) {
  //keep going
}

//finally run.  Android is so slow...
clickHandler();
                        </code></pre>
						<aside class="notes">
                            If we built apps this way, they wouldn't work very well
						</aside>

                    </section>
                    <section data-background-image="images/BTm1H.png" data-background="rgba(51,51,44, 255) center" data-background-size="contain"
                             data-background-repeat="no-repeat">
                        <aside class="notes">
                            In Javascript, you have one thread, so you need to take advantage of it's evented architecture.<br/>
                            JS is really good at queuing things up to run when events signal that they're ready
                        </aside>
                    </section>
                    <section data-background="white center" data-background-image="images/mobiledevices.jpg" data-background-size="contain" data-background-repeat="no-repeat">
                        <aside class="notes">
                            Run loop draws (16ms to complete it's loop and still feel fast)<br/>
                            Gotta run things in bg so they don't block
                        </aside>
                    </section>
				</section>

				<section>
					<h1>Ok, got it</h1>
					<h3>Is there anything more?</h3>
				</section>
                <section data-background-size="contain" data-background="black center" data-background-repeat="no-repeat" data-background-image="images/wfg32.gif"></section>

				<section  data-background-color="black" >
					<h2 style="color:#fff">Why is it hard?</h2>

                    <section data-background-image="">

                    </section>
					<section data-background-repeat="no-repeat" data-background-image="images/2000px-Apple_logo_Think_Different_vectorized.svg.png" data-background-size="contain" data-background="black center" >

						<aside class="notes">Different way of thinking</aside>
					</section>
					<section>
                        <img src="images/bttf_time_machine_ebay_lead.jpg"/>
						<aside class="notes">
							Have to start thinking about what will eventually happen.  If this, then this, then this..
                            <br/><br/>
							Log a function to occur eventually, written now
						</aside>

					</section>
					<section>
						<img src="images/meme-functions.jpg">
						<aside class="notes">
							Break it down into units
						</aside>
					</section>

					<section>
						<img style="margin-top:100px" src="images/IMG_3576-copy.jpeg"/>
						<aside class="notes">
							By the time your "asynchronous" code is done, your view might not be there anymore
                            <br/><br/>
							Android example (activity requests a network resource, puts in a callback handler, gone when it returns)
						</aside>
					</section>
					<aside class="notes">
						I've done these callbacks, why is this a big deal?
					</aside>

				</section>

				<section>
					<h2>How does it go wrong?</h2>
				</section>

				<section data-background="black">
					<img src="images/Heaven-or-Hell-Arrow-Way-Line-Route.jpg"/>
				</section>
				<section>
					<h3>Example - can't change backend</h3>
					<ol>
						<li>Load blog</li>
						<li>Load author</li>
						<li>Load comments</li>
						<li>Load each commentor user profile</li>
					</ol>
				</section>
				<section>
					<pre class="smallest stretch" ><code style="font-size:25px !important; line-height:30px">
var blog = {};
$.get('/blogs/1', function(data){
  blog = data;
  
  $.get('/users/' + data.authorId, function(author){
    blog.author = author;
  });

  $.get('/blogs/1/comments', function(comments){
    blog.comments = comments;
    comments.forEach(function(comment){
      $.get('/users/' + data.authorId, function(author){
        comment.author = author;
      });
    });
  });
});
                    </code></pre>
				</section>

				<section>
					<h2>How it starts</h2>
					<pre class="smallest stretch" ><code class="javascript">
var blog = {};
$.get('/blogs/1', function(data){
  blog = data;

  //NEW! Featured Articles
  if (blog.isFeatured){
    $.get('/ads', function(data){
      //load ad and display in main content div
    }).fail(function(){
      //TODO: download comments/authors like a normal article... copy here??
    });
  } else {
    
    $.get('/users/' + data.authorId, function(author){
      blog.author = author;
    });

    $.get('/blogs/1/comments', function(comments){
      blog.comments = comments;
      comments.forEach(function(comment){
        $.get('/users/' + data.authorId, function(author){
          comment.author = author;
        });
      });
    });
  }
});
                    </code></pre>
				</section>
				<section>
					<section>
						<h2>Small branches continue to nest logic</h2>
					</section>
					<section>
						<h2>Eventually, you lose</h2>
					</section>
					<section>
						<pre class="smallest stretch" ><code class="javascript" data-trim>
_makePostAppend: function( params, body, options, next ){

    var self = this;
    var body;

    if( typeof( next ) !== 'function' ) next = function(){};

    // Check that the method is implemented
    if( ! self.handlePostAppend ){
      self._sendError( next, new self.NotImplementedError( ) );
      return;
    }

    // Check the IDs
    self._checkParamIds( params, body, false, function( err ){  
      self._sendErrorOnErr( err, next, function(){

        self.schema.validate(  body, function( err, body, errors ) {
          self._sendErrorOnErr( err, next, function(){

            if( errors.length ){
              self._sendError( next, new self.UnprocessableEntityError( { errors: errors } ) );
            } else {
             // Fetch the doc
              self.execAllDbFetch( params, body, options, function( err, fullDoc ){
                self._sendErrorOnErr( err, next, function(){
                 self.extrapolateDoc( params, body, options, fullDoc, function( err, doc) {
                    self._sendErrorOnErr( err, next, function(){
                        </code></pre>
					</section>
					<section>
						<h5>continued</h5>
						<pre class="smallest stretch" ><code class="javascript">
               
                      self._castDoc( doc, function( err, doc) {
                        self._sendErrorOnErr( err, next, function(){

                          // Actually check permissions
                          self.checkPermissionsPostAppend( params, body, options, doc, fullDoc, function( err, granted ){
                            self._sendErrorOnErr( err, next, function(){

                              if( ! granted ){
                                self._sendError( next, new self.ForbiddenError() );
                              } else {

                                // Clean up body from things that are not to be submitted
                                //if( self.schema ) self.schema.cleanup( body, 'doNotSave' );
                                self.schema.cleanup( body, 'doNotSave' );

                                // Paranoid check
                                // Make sure that the id property in the body does match
                                // the one passed as last parameter in the list of IDs
                                body[ self.idProperty ] = params[ self.idProperty ];

                                self.execPostDbAppend( params, body, options, doc, fullDoc, function( err, fullDocAfter ){

                        </code></pre>
					</section>
					<section>
						<h5>continued</h5>
						<pre class="smallest stretch" ><code class="javascript">
                                  self._sendErrorOnErr( err, next, function(){
                                    self.extrapolateDoc( params, body, options, fullDocAfter, function( err, doc) {
                                      self._sendErrorOnErr( err, next, function(){

                                        self._castDoc( fullDocAfter, function( err, docAfter) {
                                          self._sendErrorOnErr( err, next, function(){

                                            // Remote request: set headers, and send the doc back (if echo is on)
                                            if( self.remote ){
                                              if( self.echoAfterPostAppend ){

                                                 self.prepareBeforeSend( docAfter, function( err, docAfter ){
                                                   self._sendErrorOnErr( err, next, function(){

                                                      self.afterPostAppend( params, body, options, doc, fullDoc, docAfter, fullDocAfter, function( err ){
                                                        self._sendErrorOnErr( err, next, function(){

                                                          self._res.json( 200, docAfter );

                                                        });
                                                      });
                                                   })
                                                 })
                                              } else { 
                                                self.afterPostAppend( params, body, options, doc, fullDoc, docAfter, fullDocAfter, function( err ){
                        </code></pre>
					</section>
					<section>
						<h5>continued</h5>
						<pre class="smallest stretch" ><code class="javascript">
                                                  self._sendErrorOnErr( err, next, function(){

                                                    self._res.send( 204, '' );

                                                  });
                                                });

                                              }
                                            // Local request: simply return the doc to the asking function
                                            } else {

                                              self.prepareBeforeSend( docAfter, function( err, docAfter ){
                                                self._sendErrorOnErr( err, next, function(){

                                                  self.afterPostAppend( params, body, options, doc, fullDoc, docAfter, fullDocAfter, function( err ){
                                                    self._sendErrorOnErr( err, next, function(){

                                                      next( null, docAfter, self.idProperty );

                                                    })
                                                  })

                                                })
                                              })
                                            }
                        </code></pre>
					</section>
					<section>
						<h5>finally</h5>
						<pre class="smallest stretch" ><code class="javascript">
                                          })
                                        });
                                      });
                                    })
                                  }) // err
                                }) // execPostDbAppend

                              } // granted

                            })
                          }) 

                        }) 
                      }) 
                    })
                  }) 
                }) // err
              }) // checkPermissionsPostAppend
            } // errors.length

          }) // err
        }) // self.validate
      }) // err
    }) // self.validate
  },

                        </code></pre>
					</section>
					<section>
						<pre class="smallest stretch" ><code class="javascript" style="font-size:6px;line-height:4px;">
_makePostAppend: function( params, body, options, next ){

    var self = this;
    var body;

    if( typeof( next ) !== 'function' ) next = function(){};

    // Check that the method is implemented
    if( ! self.handlePostAppend ){
      self._sendError( next, new self.NotImplementedError( ) );
      return;
    }

    // Check the IDs
    self._checkParamIds( params, body, false, function( err ){  
      self._sendErrorOnErr( err, next, function(){

        self.schema.validate(  body, function( err, body, errors ) {
          self._sendErrorOnErr( err, next, function(){

            if( errors.length ){
              self._sendError( next, new self.UnprocessableEntityError( { errors: errors } ) );
            } else {

              // Fetch the doc
              self.execAllDbFetch( params, body, options, function( err, fullDoc ){
                self._sendErrorOnErr( err, next, function(){


                  self.extrapolateDoc( params, body, options, fullDoc, function( err, doc) {
                    self._sendErrorOnErr( err, next, function(){

                      self._castDoc( doc, function( err, doc) {
                        self._sendErrorOnErr( err, next, function(){

                          // Actually check permissions
                          self.checkPermissionsPostAppend( params, body, options, doc, fullDoc, function( err, granted ){
                            self._sendErrorOnErr( err, next, function(){

                              if( ! granted ){
                                self._sendError( next, new self.ForbiddenError() );
                              } else {

                                // Clean up body from things that are not to be submitted
                                //if( self.schema ) self.schema.cleanup( body, 'doNotSave' );
                                self.schema.cleanup( body, 'doNotSave' );

                                // Paranoid check
                                // Make sure that the id property in the body does match
                                // the one passed as last parameter in the list of IDs
                                body[ self.idProperty ] = params[ self.idProperty ];

                                self.execPostDbAppend( params, body, options, doc, fullDoc, function( err, fullDocAfter ){
                                  self._sendErrorOnErr( err, next, function(){

                                    self.extrapolateDoc( params, body, options, fullDocAfter, function( err, doc) {
                                      self._sendErrorOnErr( err, next, function(){

                                        self._castDoc( fullDocAfter, function( err, docAfter) {
                                          self._sendErrorOnErr( err, next, function(){

                                            // Remote request: set headers, and send the doc back (if echo is on)
                                            if( self.remote ){
                                              if( self.echoAfterPostAppend ){

                                                 self.prepareBeforeSend( docAfter, function( err, docAfter ){
                                                   self._sendErrorOnErr( err, next, function(){

                                                      self.afterPostAppend( params, body, options, doc, fullDoc, docAfter, fullDocAfter, function( err ){
                                                        self._sendErrorOnErr( err, next, function(){

                                                          self._res.json( 200, docAfter );

                                                        });
                                                      });
                                                   })
                                                 })
                                              } else { 

                                                self.afterPostAppend( params, body, options, doc, fullDoc, docAfter, fullDocAfter, function( err ){
                                                  self._sendErrorOnErr( err, next, function(){

                                                    self._res.send( 204, '' );

                                                  });
                                                });

                                              }

                                            // Local request: simply return the doc to the asking function
                                            } else {

                                              self.prepareBeforeSend( docAfter, function( err, docAfter ){
                                                self._sendErrorOnErr( err, next, function(){

                                                  self.afterPostAppend( params, body, options, doc, fullDoc, docAfter, fullDocAfter, function( err ){
                                                    self._sendErrorOnErr( err, next, function(){

                                                      next( null, docAfter, self.idProperty );

                                                    })
                                                  })

                                                })
                                              })
                                            }

                                          })
                                        });

                                      });
                                    })


                                  }) // err
                                }) // execPostDbAppend

                              } // granted


                            })
                          }) 

                        }) 
                      }) 

                    })
                  }) 

                }) // err
              }) // checkPermissionsPostAppend

            } // errors.length

          }) // err
        }) // self.validate

      }) // err
    }) // self.validate
  },

                        </code></pre>
					</section>
					<section>
						<h1>Convinced?</h1>
					</section>
				</section>

                <section data-background-image="images/Problems-solving.jpg"
                        data-background-size="contain" data-background="black center" data-background-repeat="no-repeat">

                </section>
				<section data-background-image="images/fractal_10.jpg" class="dark bg-fade">
					<h1>Patterns</h1>
					<p style="font-size:1.6em">aka, Great, what do I do with this knowledge?</p>
				</section>

				<section data-background="white">
					<section data-background-image="images/keep-calm-and-call-me-later-1.png" data-background-size="contain" data-background="black center" data-background-repeat="no-repeat" class="bg-big-fade">
                        <h2>Callbacks</h2>
<br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
                    </section>
					<section>
                        <h2>Javascript</h2>
						<pre class="smaller"><code>
  readABigFile('filename.jpg', 
    function afterRead(error, file){
      console.log("Here's my file " + file);
    });
						</code></pre>
					</section>
					<section>
                        <h2>Java</h2>
						<pre class="smaller"><code style="font-size:24px">
  readABigFile(new OnFileReadListener(){
     @Override
     public void onFileRead(File file){
        Log.d(TAG, "Read file " + file);
     }
     @Override
     public void onError(Exception e){
        Log.e(TAG, "Error reading file " + e);
     }
  });
						</code></pre>
					</section>
                    <section>
                        <h2>Java 8!</h2>
						<pre class="smaller"><code style="font-size:24px">
  readABigFile(file -> {
    Log.d(TAG, "Read file " + file);
  },
  ex -> {
    Log.e(TAG, "Error reading file " + e);
  });
                        </code></pre>
                        <aside class="notes">
                            Java 8 version

                        </aside>
                    </section>
                    <section data-background-image="images/Applause-Hands-dreamstime_m_2437415.jpg" class="hide-title" >

                    </section>


                    <section data-background-image="images/tool-box1-624x361.jpg" class="bg-blur">
                        <h3>When to use</h3>
                        <p>When your result will happen asynchronously :)</p>
                        <p>Simple use cases (most)</p>
                        <aside class="notes">
                            A lot of code doesn't need some higher level abstraction.  Don't go down a path of libraries and patterns if you don't need them.
                        </aside>
                    </section>

                    <section data-background="center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
                        <h3 class="positives">What's not to like?</h3>
                        <p>Built-in</p>
                        <p>Easy to Read</p>
						<aside class="notes">
							No 3rd party necessary
						</aside>
					</section>

                    <section data-background-image="images/danger.jpg" data-background-size="contain" data-background="white center" data-background-repeat="no-repeat">
                    </section>
                    <section class="bg-big-fade" data-background-size="contain" data-background="white center" data-background-repeat="no-repeat"
                               data-background-image="images/sotp.jpg">
                        <h3 class="shaded-8" >Might be doing it wrong if:</h3>
                        <ul style="font-size:1.5em" >
                            <li class="fragment">You read the code synchronously</li>
                            <li class="fragment">Create callbacks in callbacks</li>
                            <li class="fragment">Forget to call back</li>
                        </ul>
                        <aside class="notes">
                            If you return and forget to call the callback, the code won't ever continue.  This is a fundamental difference from sequential programs.
                        </aside>
                    </section>

                    <section   style="background: rgba(255,255,255,0.8)" class="bg-fade" data-background-size="contain"
                               data-background="white center" data-background-repeat="no-repeat"
                               data-background-image="images/wunda-weeder-garden-pants-solar.jpg">
                        <h3>Might be over-thinking it if:</h3>
                        <ul style="font-size:1.5em" >
                            <li  class="fragment">Always using higher abstractions</li>
                        </ul>
                        <aside class="notes">
                            If you return and forget to call the callback, the code won't ever continue.  This is a fundamental difference from sequential programs.
                        </aside>
                    </section>
				</section>

                <section data-background-image="images/154558-004-DB68FE47.jpg" class="bg-blur">
                    <h2>Callback Libraries</h2>
                    <p>Add coordination across callbacks</p>
                </section>

                <section>
                    <section>
                        <h2>javascript - async.js</h2>
                        <p>node.js style callbacks</p>
                        <pre class="smaller"><code class="javascript" >
//nodejs style functions
function(err, data){

  //err is always first
  next(err);

  //if no error, call with null or undefined
  next(null, result);
}
                        </code></pre>
                    </section>
                    <section>
                        <h2>async.js - parallel</h2>
                        <pre class="smaller stretch"><code class="javascript" data-trim>
async.parallel([
  function downloadBlog(next){
    downloadBlogAComments(next);
  },
  function downloadUsers(next){
    downloadBlogAUsers(next);
  }
], function done(err, results){
    if (err) return alert(err);
    var blogWithComments = results[0];
    var users = results[1];
    display(blogWithComments, users);
});

//limit concurrent runners
async.parallelLimit([...], 5, cb);
                        </code></pre>
                    </section>
                    <section>
                        <h2>async.js - waterfall</h2>
                        <pre class="smaller stretch"><code class="javascript" data-trim>
async.waterfall([
  function download(next){
    getBlog(next);
  },
  function users(blog, next){
    getBlogUsers(blog, next);
  },
  function avatars(blog, users, next){
    getUserAvatars(function(err, avatars){
      next(err, blog, users, avatars);
    });
  }
], function done(err, blog, users, avatars){
    if (err) return alert(err);
    display(blog, users, avatars);
});
                        </code></pre>
                    </section>
                    <section>
                        <h2>async.js - more</h2>
                       <ul style="font-size: 1.5em">
                           <li>map</li>
                           <li>filter</li>
                           <li>each</li>
                           <li>eachSeries</li>
                           <li>[much more]</li>
                       </ul>
                    </section>
                </section>
                <section>
                    <h2>Android - Bolts</h2>
                    <pre class="smaller stretch"><code class="Java" style="font-size: 0.9em; line-height: 1.5em">
saveAsync(obj).continueWith(new Continuation&lt;ParseObject, Void>() {
  public Void then(Task&lt;ParseObject> task) throws Exception {
    if (task.isCancelled()) {
      // the save was cancelled.
    } else if (task.isFaulted()) {
      // the save failed.
      Exception error = task.getError()
    } else {
      // the object was saved successfully.
      ParseObject object = task.getResult();
    }
    return null;
  }
});
                       </code></pre>
                </section>
                <section>
                    <h2>Android - Bolts: Series</h2>
                    <pre class="smallest stretch"><code data-trim>
ParseQuery&lt;ParseObject> query = ParseQuery.getQuery("Comments");
query.whereEqualTo("post", 123);

findAsync(query).continueWithTask(new Continuation&lt;List&lt;ParseObject>, Task&lt;Void>>() {
  public Task&lt;Void> then(Task&lt;List&lt;ParseObject>> results) throws Exception {

    // Create a trivial completed task as a base case.
    Task&lt;Void> task = Task.forResult(null);
    for (final ParseObject result : results) {

      // For each item, extend the task with a function to delete the item.
      task = task.continueWithTask(new Continuation&lt;Void, Task&lt;Void>>() {
        public Task&lt;Void> then(Task&lt;Void> ignored) throws Exception {
          // Return a task that will be marked as completed when the delete is finished.
          return deleteAsync(result);
        }
      });
    }
    return task;
  }
}).continueWith(new Continuation&lt;Void, Void>() {
  public Void then(Task&lt;Void> ignored) throws Exception {
    // Every comment was deleted.
    return null;
  }
});
                    </code></pre>
                    <aside class="notes">
                        https://github.com/BoltsFramework/Bolts-Android
                    </aside>
                </section>



                <section data-background-image="images/tool-box1-624x361.jpg" class="bg-blur">
                    <h3>When to use</h3>
                    <p class="fragment">Find nests in nests</p>
                    <p class="fragment">Prefer over Promises, Rx</p>
                    <aside class="notes">
                        Personal preference
                    </aside>
                </section>

                <section data-background="white center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
                    <h3 class="positives">What's not to like?</h3>
                    <p>Consistent structure</p>
                    <p>Clean solution</p>
                    <aside class="notes">
                        Follows the pattern of the nodejs callbacks
                        Callback coordination is complex.  These are pretty clean ways to handle things
                    </aside>
                </section>

                <section data-background-image="images/Quicksand-warning.jpg"  data-background="white center" data-background-size="contain" data-background-repeat="no-repeat"  >
                </section>
                <section  data-background="white center" data-background-size="contain" data-background-repeat="no-repeat"  data-background-image="images/reply-all-email-fail.jpg">
                    <h2 class="shaded">Rookie mistakes:</h2>
                    <div class="fragment shaded">
                    <ul style="font-size:1.5em" >
                        <li>Still forget to call back</li>
                        <li class="fragment">Send data to error param (nodejs)</li>
                        <li class="fragment">Not try/catch errors</li>
                    </ul>
                    </div>
                    <aside class="notes">
                        If you return and forget to call the callback, the code won't ever continue.
                        <br/>This is a fundamental difference from sequential programs.

                        <p>Still inherit some problems of callbacks</p>
                    </aside>
                </section>

                <section data-background-size="contain" data-background="white center" data-background-repeat="no-repeat"
                         data-background-image="images/vista.jpg">
                    <h2 class="shaded">You might be "over-engineering" it:</h2>
                    <div class="fragment shaded">
                        <ul style="font-size:1.5em" >
                        <li>Use for single callbacks, synchronous loops</li>
                        <li class="fragment">Roll your own</li>
                        <li class="fragment">Parallel inside waterfall</li>
                    </ul>
                     </div>
                    <aside class="notes">
                        <p>Enforced Opinion - remember that when you design arch</p>
                        <p>3rd party lib - but better than your own</p>
                    </aside>
                </section>

				<section data-background="white">
					<section data-background-image="images/puppet-master.png" class="bg-slight-blur">
                        <h2>Delegation Pattern</h2>
						<p>Hand off control to 1 other actor</p>
						<aside class="notes">
						Android: think, registering activity callback when an action happens in a fragment (clicked on button)
						</aside>
					</section>
					<section>
                        <h2>Delegation Pattern</h2>
                        <pre class="smallest stretch" ><code data-trim>
public interface FragmentListener {
  public void buttonClicked();
  public boolean shouldAcceptClick();
  public void valueChanged(int value);
}

public GameViewActivity extends Activity implements FragmentListener {
   ...

  @Override
  public boolean shouldAcceptClick() {
    return isAdmin && isFormFilledOut;
  }

  @Override
  public void buttonClicked(){
    startActivity(...);
  }

  @Override
  public void valueChanged(int value){
    this.value = value;
    this.isFormFilledOut = (value != 0);
  }
}
                        </code></pre>
					</section>

					<section>
                        <h2>Delegation Pattern</h2>
                        <pre class="smallest stretch" ><code data-trim>
public GameFragment extends Fragment {
  private FragmentListener listener;
  ...

  @Override
  public void onAttach(Activity activity) {
    super.onAttach(activity);
    try {
        listener = (FragmentListener) activity;
    } catch (ClassCastException e) {
        throw new ClassCastException(activity.toString()
                            + " must implement FragmentListener");
    }
  }
  @Override
  public void onClick(View v) {
    listener.buttonClicked();
  }

  ...
}
                        </code></pre>
					</section>


                    <section data-background-image="images/tool-box1-624x361.jpg" class="bg-blur">
                        <h3>When to use</h3>
                        <p class="fragment">Presenters/Data Adapters</p>
                        <p class="fragment">Service "instance"</p>

                        <aside class="notes">
                            UI Component - if your component has one "presenter" or driver, it can use a delegate pattern to communciate effectively back and forth<br/>
                            Service Instance - you CAN use this pattern to allow works to subscribe to callbacks when things download/succeed.  See iOS NSURLSession handlers on the original class<br/>
                            Coupling - also applicable if you have a service that is ONLY ever going to be for one view<br/>
                        </aside>
                    </section>

                    <section data-background="white center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
                        <h3 class="positives">What's not to like?</h3>

                        <p>Two-way Control</p>
                        <p>Very Clear API (interface)</p>
                        <aside class="notes">
                            Not just subscribing - can send data, request data, etc
                            <br/>
                            Self documenting.  Advantage over some other patterns

                        </aside>
                    </section>

                    <section data-background-image="images/signs-caution_00389671.jpg">
                    </section>
                    <section  data-background="white center" data-background-size="contain" data-background-repeat="no-repeat"
                              data-background-image="images/steve-urkel-did-i-do-that-676x540.png">
                        <h2 class="shaded">It happens...</h2>
                        <br/><br/><br/>
                        <div class="fragment shaded">
                            <ul style="font-size:1.5em" >
                                <li >Too much functionality in one interface</li>
                                <li class="fragment">Forget to de-register</li>
                                <li class="fragment">Singleton backend, switching delegate</li>
                            </ul>
                        </div>
                        <aside class="notes">
                            Don't make someone implement a huge interface if they don't need it
                            <br/>
                            Might end up getting callbacks when you don't want them anymore
                            <br/>
                            Story about project where we did this (sometimes doesn't get handed off soon enough)
                        </aside>
                    </section>

				</section>
				<section>
                    <section data-background-image="images/Observer.png" class="bg-fade">
                        <h2 class="border-light">Observer Pattern</h2>
                        <p  class="border-light">"Observe" an object's state changes</p>

                        <aside class="notes">
                            Observers register themselves with the subject.<br/>
                            Subject maintains the list of its  dependents (Observers), and it broadcast notification  to all its dependents when it’s state changes.<br/>
                            Observers de-register explicitly when they no more want to be notified.<br/>
                        </aside>
                    </section>
                    <section>
                        <h2>Backbone.js</h2>
                        <pre class="smaller stretch"><code>
 //view
 initialize: function() {
   this.listenTo(this.model, 'change', this.render);
   this.listenTo(this.model, 'destroy', this.remove);
 },
                        </code></pre>
                    </section>

                    <section>
                        <h2>Adding Observability</h2>
                        <pre class="smaller stretch"><code>
 var EventEmitter = require('events').EventEmitter;
 var util = require('util');

 var MyModule = {};
 EventEmitter.call(MyModule);
 util.inherits(MyModule, EventEmitter);

 MyModule.set = function(elems){
   this._set(elems);
   this.emit('change', elems);
 }
 ...

 var myModule = require('modules/mymodule');
 myModule.on('change', function(){...
                        </code></pre>
                        <aside class="notes">
                            EventEmitter is a NodeJS lib
                        </aside>
                    </section>
                    <section>
                        <h2>Android</h2>
                        <pre class="smaller"><code>
 textField.addTextChangedListener(this);
 @Override
 public void afterTextChanged(Editable s) {
    String value = s.getText().toString();
 }
                        </code></pre>
                    </section>
                    <section data-background-image="images/tool-box1-624x361.jpg" class="bg-blur">
                        <h3>When to Use</h3>
                        <p class="fragment">View/Model Changes</p>
                        <p class="fragment">Backbone.js/Frameworks</p>
                        <p class="fragment">DOM</p>
                        <p class="fragment">Lots of other places</p>
                    </section>

                    <section data-background="center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
                        <h3>What's not to like?</h3>
                        <p>Loose Coupling</p>
                        <p>Specific Object of Interest</p>
                        <p>One or Many Subscribers</p>
                        <aside class="notes">
                            Publisher doesn't know who is listening
                            <br/>
                            Not just willy-nilly listening to events.  Most of the time this is great, but sometimes you need to know a "new object" got created.

                        </aside>
                    </section>
                    <section class="bg-slight-blur" data-background-image="images/eiMd9Le4T.png" data-background="white center">
                    </section>

                    <section data-background-image="images/SC_BlessYourHeart_popup.jpg" data-background-repeat="no-repeat" data-background-size="contain" data-background="white center">
                        <h2 class="shaded">Bless your heart</h2>
                        <div class="shaded fragment">
                            <p class="">Forgot to de-register</p>
                            <p class="fragment">Waiting for events that already happened</p>
                            <p class="fragment">Poorly documented</p>
                        </div>
                        <aside class="notes">
                            View might disappear, but still registered for events
                            <br/>
                            Sometimes we forget that events don't have state.  Forces a load then listen pattern (sync, then async)
                            <br/>
                            Can make intent of the api a little tough to follow.  There's no self-documenting structure in many cases.
                        </aside>
                    </section>

                    <section data-background-image="images/j400_976851.jpg">
                        <h2 class="shaded">Overkill?</h2>
                        <div class="shaded fragment">
                            <p class="">Rolled your own</p>
                            <p class="fragment">Skipped straight to reactive</p>
                            <p class="fragment">Obsessed over automatic data-binding</p>
                            <p class="fragment">Abstracted away from observing actual objects</p>
                        </div>
                        <aside class="notes">
                            Built into many popular frameworks
                            <br/>
                            Reactive: don't automatically jump to reactive.  Can be overkill in many situations
                            <br/>
                            Data binding: sometimes you want to auto-update state all on it's own and skip manual changes.  That CAN be great, but sometimes hedges towards overkill.  Just beware of your line.
                            <br/>
                            Abstract: bleed towards message bus
                        </aside>
                    </section>
				</section>
				<section data-background="white">
                    <section data-background-size="contain" data-background="white center"
                             data-background-image="images/336419_10151003106623944_1796915251_o.jpg"
                             data-background-repeat="no-repeat">
                        <h2 class="shaded">Promises</h2>
                        <p class="shaded">Synchronous looking async</p>

                        <aside class="notes">
                            NOTE: has a compliant spec
                            Go into "what it is"
                        </aside>
                    </section>
                    <section data-background="center" data-background-image="images/wonka.jpg" data-background-repeat="no-repeat" data-background-size="contain">
                    </section>
                    <section data-background="white center" data-background-image="images/wonka.jpg" class="bg-fade" data-background-repeat="no-repeat" data-background-size="contain">
                        <p class="shaded" data-fragment-index="0">Object <span style="font-size: 0.7em">that will</span></p>
                        <p class="shaded fragment" data-fragment-index="1"><i style="font-size: 1.3em">always</i> either <b style="color: green">resolve</b> or <b style="color: red">reject</b></p>
                        <p class="shaded fragment">once</p>
                    </section>
                    <section data-background-image="images/6929697914_0fd3bd4457_b.jpg" data-background-size="contain">
                        <aside class="notes">
                            Immutable once resolved <br/>
                            this means you can reuse a resolved promise and get the result
                        </aside>
                    </section>

                    <section data-background-image="images/Indiana-Jones-and-the-Temple-of-Doom-Mola-Ram-Amrish-Puri-heart.png" data-background-size="contain">

                    </section>
                    <section>
                        <h2>Pyramid of Doom</h2>
                        <pre><code>
step1(function (value1) {
  step2(value1, function(value2)
    step3(value2, function(value3) {
      step4(value3, function(value4) {
        // Do something with value4
      });
    });
  });
});
                        </code></pre>
                    </section>
                    <section>
                        <h2>Q - javascript</h2>
                        <pre class="stretch"><code>
  Q.fcall(promisedStep1)
  .then(promisedStep2)
  .then(promisedStep3)
  .then(promisedStep4)
  .then(function (value4) {
    //Do something with value4
  })
  .catch(function (error) {
    //Handle errors from ANY above steps
  })
  .done();
                        </code></pre>
                        <aside class="notes">
                            Ending a promise chain makes sure that,
                            <br/>if an error doesn’t get handled before the end, it will get rethrown and reported.
                        </aside>
                    </section>
                    <section>
                        <h2>What's in a promise?</h2>
                        <pre class="stretch"><code class="javascript" data-trim>
 //create
 var deferred = Q.defer();

 FS.readFile("foo.txt", "utf-8",
   function (error, text) {
     if (error) {
        deferred.reject(new Error(error));
     } else {
        deferred.resolve(text);
     }
   });

 //return the promise (not the result)
 return deferred.promise;
                        </code></pre>
                    </section>
                    <section>
                        <h2>Return types</h2>
                        <pre class="stretch smaller"><code class="javascript" data-trim>
 function authenticate() {
   return getUsername()
    .then(function (username) {
      //naive cache
      var cachedUser = cache[username];
      // --> returns synchronous params
      return [username, user];
    })
    .spread(function (username, user) {
       // --> returns synchronous user
       if (user) return user;

       // --> returns promise
       return getUser(username);
    })
    .then(function (user) {
       ...
                        </code></pre>
                        <aside class="notes">
                            Important because it lets you chain.  One time you return a promise, another it's a direct object
                        </aside>
                    </section>
                    <section>
                        <h2>Concurrent</h2>
                        <pre><code class="java">
return Q.all([
    eventualAdd(2, 2),
    eventualAdd(10, 20)
]);
                        </code></pre>
                        <aside class="notes">
                            Works with runnable, callable, future
                        </aside>
                    </section>
                    <section>
                        <h2>Easy to integrate</h2>
                        <pre><code class="javascript">
 return Q.nfcall(FS.readFile,
    "foo.txt",
    "utf-8");
                        </code></pre>
                        <pre><code class="javascript">
 return Q(jQuery.ajax({
    url: "foobar.html",
    type: "GET"
 })).then(function (data) {
    // on success
 }, function (xhr) {
    // on failure
 });
                        </code></pre>
                        <aside class="notes">
                            jQuery deferred follows a non standard spec for promises<br/>
                            includes things like - promises can change, callbacks aren't guaranteed to be async, etc
                        </aside>
                    </section>
                    <section>
                        <h1>Android</h1>
                        <h2>JDeferred</h2>
                        <aside class="notes">
                            NOTE: not Promise/A+ spec compliant
                        </aside>
                    </section>
                    <section>
                        <h2>Promise callbacks</h2>
                        <pre><code class="java">
  .then(…)
  .done(…)
  .fail(…)
  .progress(…)
  .always(…)
                        </code></pre>
                        <aside class="notes">
                            Works with runnable, callable, future
                        </aside>
                    </section>
                    <section>
                        <h2>Combined callbacks</h2>
                        <pre><code class="java">
  .when(p1, p2, p3, …).then(…)
                        </code></pre>
                        <aside class="notes">
                            Run multiple promises concurrently, wait for finish
                        </aside>
                    </section>
                    <section>
                        <h2>Load from DB or WEB</h2>
                        <pre class="stretch smallest"><code class="java" data-trim>

Promise promise = blogDAO.loadFromDB(blogId);

promise.then(new DonePipe&ltBlog, Throwable, Void, Void>() {
  @Override
  public Promise&ltBlog, Throwable, Void> onDone(Blog blog) {
    if (blog != null) {
       return new DeferredObject&ltBlog, Throwable, Void>()
                        .resolve(blog);
    } else {
       return blogRestService.loadBlog(blogId);
    }
  }
})
.done(new DoneCallback&ltBlog>() {
  @Override
  public void onDone(Blog rejection) {
    //display blog
  }
})
.fail(new FailCallback&ltThrowable>() {
  @Override
  public void onFail(Throwable exception) {
    //handles any thrown exceptions
  }
});

                        </code></pre>
                    </section>
                    <section data-background-image="images/mckayladisappointed.jpg">

                    </section>

                    <section>
                        <h2>LAMBDAS!</h2>
                        <pre class="stretch smaller"><code class="java" data-trim>

return blogDAO.loadFromDB(blogId)
 .then( (blog, throwable) -> {
   if (blog != null)
     //resolve immediate
     return new DeferredObject&ltBlog, Throwable, Void>()
                        .resolve(blog);
   else
     //resolve later
     return blogRestService.loadBlog(blogId);
 })
 .done(blog -> {
   //display blog
 })
 .fail(exception -> {
   //handles any thrown exceptions
 });

                        </code></pre>
                    </section>
                    <section data-background-image="images/tool-box1-624x361.jpg" class="bg-blur">
                        <h3>When to Use</h3>
                        <p class="fragment">Coordinated Async Calls (parallel/sequence)</p>
                        <p class="fragment">Backend Ajax -> DB Storage</p>
                        <p class="fragment">Where already available</p>
                        <aside class="notes">
                            JS - Built into es6<br/>
                            JS - Built into Chrome 32, Opera 19 & Firefox 29 (small polyfill exists)<br/>
                            Android - when you can use retrolamda and RxJava is too much for you<br/>
                        </aside>
                    </section>
                    <section data-background="center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
                        <h3>What's not to like?</h3>
                        <p>Mimics Synchronous Code</p>
                        <p>Great Error Handling</p>
                        <p>All Paths Exit</p>
                        <p>Can Resolve Immediately or Async</p>
                        <aside class="notes">
                            Looks sync: Looks like synchronous code
                            <br/>
                            Errors: Easily bubble up typed errors, catch uncaught exceptions.
                            <br/> --> One gotcha - syntax can take a second error handler.  You should still have a good strategy for sending up typed errors or handling them as they occur.  Treat it like Try/Catch rules.
                            <br/>
                            All Paths Exit: You can't screw up and get stuck.  It will always go to the next block
                            <br/>
                            Resolve immediate: Return state immediately and still go to the callbacks
                        </aside>
                    </section>
                    <section class="bg-slight-blur" data-background-image="images/caution-1.jpg" data-background-size="contain" data-background="white center" data-background-repeat="no-repeat">
                    </section>

                    <section data-background="center" data-background-image="images/Wanna-know-how-I-got-these-scars-the-joker-9213269-622-455.jpg" data-background-repeat="no-repeat" data-background-size="contain">
                        <h2 class="shaded">May scar</h2>
                        <div class="fragment shaded">
                            <p>Differing implementations</p>
                            <p class="fragment">Can discourage testing "units"</p>
                            <p class="fragment">De-register when view disappears</p>
                            <p class="fragment">Catch all errors together</p>
                            <p class="fragment">Promises hell</p>
                            <p class="fragment">Hard to grasp initially</p>
                        </div>
                        <aside class="notes">
                            Libs implement different versions of what it means to have "Promises". Luckily, most things are converting to follow the Promises/A standard.
                            <br/>
                            Tests:In practice, it feels a little common to put your code in a promise block and deal with it right there.  This isn't a science, just an observed behavior.
                            <br/>
                            de-register: In some of the libraries, it can be hard to cancel the promises if your view goes out of scope.
                            <br/>
                            errors: you want to follow normal try/catch rules.  Catch errors where they make sense and deal with them, or bubble up your own typed error your can differentiate.
                            <br/>
                            promise hell: just because you're using promises doesn't mean you can't still use a pattern of nesting promises in promises.  remember to keep things shallow
                            <br/>
                            Grasp:For some reason, the behavior of promises can be a little confusing to write for yourself initially
                        </aside>
                    </section>

                    <section data-background-image="images/toomuch.jpg" data-background-size="contain" data-background="white center" data-background-repeat="no-repeat">
                        <h2 class="shaded">Might be suffocating others</h2>
                        <br/><br/>
                        <br/><br/>
                        <div class="shaded fragment">
                            <p class="">Convert everything to promises</p>
                            <p class="fragment">Or, insist on promises for your one module (not used anywhere else)</p>

                        </div>
                        <aside class="notes">
                            Some callbacks are fine as is.  Don't make everything a promise by default unless you decide that's going to be your pattern everywhere for consistency
                        </aside>
                    </section>
				</section>
				<section>
                    <section>
                        <h2>Message Bus</h2>
                        <p>Central service for sending and receiving messages</p>
                    </section>
                    <section>
                    	<h2>Android - Otto</h2>
                        <pre class="smaller "><code class="java">
bus.post(new AnswerEvent(42));

...

@Subscribe
public void answerAvailable(AnswerEvent event){
  // TODO: React to the event somehow!
}
                        </code></pre>
                    </section>
                    <section>
                        <h2>Javascript - postal.js</h2>
                        <pre class="smaller "><code class="javascript">
var subscription = postal.subscribe({
  channel: "orders",
  topic: "item.add",
  callback: function(data, envelope) {
     //handle item added
  }
});
                        </code></pre>
                        <aside class="notes">
                            data has the passed through data<br/>
                            envelope has sent timestamp, channel, etc
                        </aside>
                    </section>
                    <section>
                        <h2>Javascript - postal.js</h2>
                        <pre class="smaller "><code class="javascript">
postal.publish({
  channel: "orders",
  topic: "item.add",
  data: {
    sku: "AZDTF4346",
    qty: 21
  }
});
                        </code></pre>
                        <aside class="notes">
                            data has the passed through data
                            envelope has sent timestamp, channel, etc
                        </aside>
                    </section>

                    <section data-background-image="images/tool-box1-624x361.jpg" class="bg-blur">
                        <h3>When to use</h3>
                        <p>System-wide events</p>
                        <p class="fragment">Inter-module communication</p>
                        <p class="fragment">Want to handle EVERY event</p>
                        <p class="fragment">Library   allows easy filtering</p>
                        <aside class="notes">
                            System-wide events: think battery, network error occurred, user logged out, user logged in, startup device, app resumed, etc<br/>
                            Inter-Module Communication: communicate across views so they're not coupled, across libraries<br/>
                            Every event: don't want to constantly filter on everything ideally.  If you have a "subject", better to emit events about that subject (Observer)<br/>
                            Easily filtered: don't want a tough lib to handle getting out the bad messages<br/>
                        </aside>
                    </section>

                    <section data-background="center" data-background-image="images/positive-attitude.jpg" class="bg-blur" data-background-size="cover">
                        <h3>What's not to like?</h3>
                        <p>Completely De-Coupled</p>
                        <p>Views/models/services work independently</p>
                        <p>Components can self-register</p>
                        <aside class="notes">
                            Neither receivers or publishers know about each other

                            Can be a nice design, and the allure of completely decoupled views/models/controllers excites a certain type of dev
                            <br/>
                            Makes it so services can come and go, and anyone can subscribe to events and register themselves
                            <br/>
                            You can have an app boot-up that skips the 1 by 1 registration of your app services; they just self register
                        </aside>
                    </section>
                    <section data-background="white center" data-background-image="images/183ee6v1dn6bhpng.png"
                             data-background-repeat="no-repeat" data-background-size="contain">
                    </section>

                    <section data-background="white center" data-background-image="images/cat-biting-during-petting.jpg"
                             data-background-repeat="no-repeat" data-background-size="contain">
                        <h3 class="shaded">Known to bite</h3>
                        <div class="shaded fragment">
                            <p>- Tracing event origins/flows</p>
                            <p class="fragment">- Asking for state you need synchronously</p>
                            <p class="fragment">- Event topics too broad</p>
                        </div>
                        <aside class="notes">
                            Searching through the codebase for where events come from can be challenging.  Same with refactoring.
                            <br/><br/>
                            Not self-documenting
                            <br/>
                            State: Can get confused for something that "should" have state, and if it's your only way to get the state, you're going to start "asking" things of the bus
                            <br/>
                            Events too broad:
                            If your event can be broadcast for multiple objects, gets noisy (think blog:updated.  must filter each one by the blog id)
                            <br/>
                            Think about posting to the bus about "creating" a new blog.  If you care about the result, you need to subscribe to the "BlogCreated" event, and then figure out if it's yours, or something else.
                        </aside>
                    </section>

                    <section data-background-image="images/4599681684_d5336aa0e4_z.jpg" data-background-size="contain" data-background="white center" data-background-repeat="no-repeat">
                        <h2 class="shaded">Over-done?</h2>
                        <br/><br/>
                        <br/><br/>
                        <div class="shaded fragment">
                            <p class="">- Pub to sub</p>
                            <p class="fragment">- Making it your ONLY pattern</p>
                            <p class="fragment">- Events publish events</p>
                        </div>
                        <aside class="notes">
                            Pub to sub pattern:
                            You don't want to initiate async events on a hub just to load data.  Only do this for things that you don't care if they're not going to return until later
                           <br/>
                            If you pub to sub, might get events initiated by something else
                            <br/>
                            Combine this with the observer.  Once you want updates for a certain object, you should be listening to that object.<br/>
                            Not meant for fine-grained state<br/>
                            <br/>
                            Events publish events:
                            This starts too much of a cascading SOA without a central mechanism to see the flows<br/>

                        </aside>
                    </section>
				</section>
				<section  data-background="white center" class="bg-blur" data-background-image="images/yield_sign_page.png"
                        data-background-size="contain" data-background-repeat="no-repeat">
                    <h2>Generators</h2>
                    <p>Keywords built into language to handle async</p>
<pre><code data-trim>
yield, await, async
</code></pre>
                    <aside class="notes">
                        Built-in to EmcaScript 6 (ES6), .NET
                        <br/><br/>
                        Also sometimes called coroutines.
                        <br/><br/>
                        Generators are "shallow" coroutines that return promises
                        <br/><br/>
                        But coroutines would allow yielding in nested functions, which could modify your current objects without you knowing it
                        http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/
                        <br/><br/>
                        //promises with generators
                        http://blogs.atlassian.com/2013/11/harmony-generators-and-promises-for-node-js-async-fun-and-profit/

                    </aside>
                </section>

                <section data-background-image="images/superstreetfighter2.jpg" class="bg-fade">
                    <h2 class="shaded">Reactive Programming</h2>
                    <aside class="notes">
                        Combos of all of the above
                        <br/><br/>
                        Too much for this presentation, but includes promises, observer pattern, chaining, and other functional programming
                        <br/><br/>
                        about how the learning curve feels
                    </aside>
                </section>

                <section>
                    <section class="bg-slight-fade" data-background-image="images/Copyoferase.jpg">
                        <h2 class="shaded-8 ">Ok, how do I use this?</h2>
                        <br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
                    </section>
                    <section >
                        <h2>Services</h2>
                        <p>Promises/Callback Coordinators</p>
                        <p>Message Bus</p>
                        <aside class="notes">
                            Use promises or coordinators to have your db and rest calls coordinated
                            <br/><br/>
                            Message bus for significant events
                            <br/><br/>
                            Ignore callbacks if out of scope
                        </aside>
                    </section>
                    <section>
                        <h2>Models</h2>
                        <p>Observable</p>
                        <p>Promises</p>

                        <aside class="notes">
                            Publish events when things change (to listeners of one model)
                            <br/>
                            If your model has events itself, use promises or more observables to allow CRUD

                        </aside>
                    </section>
                    <section>
                        <h2>Views/Controllers</h2>
                        <p>Observable</p>
                        <p>Observer</p>
                        <p>Delegates</p>
                        <p>Message Bus</p>
                        <aside class="notes">
                            Observe model state
                            <br/>
                            Publish view events to subscribers
                            <br/>
                            Delegates for handing off control to helpers/presenters
                            <br/>
                            Publish user events across views with message bus
                            <br/>
                            Interact directly with service layer
                        </aside>
                    </section>

                    <section>
                        <h2>System Services</h2>
                        <p>Observable</p>
                        <p>Message Bus</p>
                        <aside class="notes">
                            Either directly observer, or get and broadcast with a service
                        </aside>
                    </section>
                    </section>
                </section>

				<section data-background="white">
					<section class="bg-big-fade" data-background-image="images/caseybluefletch.jpg">
                        <h1 class="border-light">Tips to "Retrieve"</h1>
                        <p>when you get stuck</p>
					</section>
					<section data-background-image="images/anglerfish-teeth.jpeg">
						<h2 class="shaded-8">2 deep!</h2>
                        <aside class="notes">
                            Refactor as you write and notice code nesting
                        </aside>
					</section>
					<section data-background-image="images/karate-snap-wood.jpg" data-background-size="cover" data-background-repeat="no-repeat" class="bg-fade">
						<h2>Aim for vertical</h2>
						<aside class="notes">
							Karate chop
                        </aside>
					</section>
					<section data-background-image="images/polls_600px_No_sign.svg_0345_947560_answer_2_xlarge.png" data-background-size="contain">
                        <h2>Avoid Diagonal</h2>
					</section>
					<section>
                        <h2>Focus on <span style="-webkit-filter: blur(4px);">Readability</span></h2>
					</section>
                    <section>
                        <h2>De-register when Views <span class="fade-on-display">Disappear</span></h2>
                        <aside class="notes">
                            If you reference views/elements that might be gone when your callback runs, you may end up killing your app.  This is true of almost every async pattern and is something you need to think about.
                            <br/>
                            Backbone handles this for you by inversing the ownership of the model events so that the view holds the registration and will kill them off on destroy.
                        </aside>
                    </section>
					<section data-background-image="images/clean_code.png" data-background-size="contain"
                            class="bg-blur">
						<h2>Write testable functions</h2>
                        <p class="fragment">then add coordination</p>
						<aside class="notes">
							This helps to think in terms of little units, as well as testing
						</aside>
					</section>
                    <section class="dark" data-background-image="images/Hammer-and-Screw.jpg" data-background-repeat="no-repeat" class="bg-fade">
                        <h2 style="margin-top:350px;">Hammers are not screwdrivers</h2>
                        <aside class="notes">
                            Use patterns when you need them!!!
                        </aside>
                    </section>
					<section data-background-image="images/wheel.png" data-background-repeat="no-repeat" class="bg-slight-blur">
						<h2>Don't reinvent the wheel.</h2>
                        <aside class="notes">
                            Use libraries that exist - you'll end up breaking something
                            <br/>
                            If you invent something, you will probably be the only one that understands it.
                        </aside>
					</section>
				</section>
                <section class="dark" data-background-image="images/neurons-firing-in-the-brain.jpg">
                    <h2>Burn it in</h2>
                </section>
                <section>
                    <h2>Questions</h2>
                    <br/>
                    <p><a href="https://github.com/blakebyrnes/async-programming-presentation">https://github.com/blakebyrnes/async-programming-presentation</a></p>
                    <br/>
                    <dl style="font-size:30px;">
                      <dt><em>extroverts:</em></dt><dd>raise hands</dd>
                      <dt><em>introverts:</em></dt><dd><a href="mailto:blake.byrnes@bluefletch.com">blake.byrnes@bluefletch.com</a></dd>
                      <dt><em>marketers:</em></dt><dd><span style="text-decoration: line-through;color:red">@blakebyrnes</span>  <strong>@prpatel</strong></dd>
                    </dl>
                </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: false,
				progress: true,
				history: true,
				center: true,
				slideNumber: false,

				transition: 'convex', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
            Reveal.configure({
                keyboard: {
                    13: 'next', // go to the next slide when the ENTER key is pressed
                    37 : 'prev',
                    39 : 'next'
                }
            });
		</script>

	</body>
</html>
