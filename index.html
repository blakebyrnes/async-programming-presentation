<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Asynchronous Programming Techniques</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">
		<link rel="stylesheet" href="css/preso.css" >

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
        <style>

            .backgrounds .bg-blur {
                -webkit-filter: blur(6px) opacity(20%);
            }
            .backgrounds .bg-fade {
                -webkit-filter: blur(1px) opacity(60%);
            }
            h2.shadow,h3.shadow {
                text-shadow: 2px 4px 3px rgba(0,0,0,0.3);
            }
            h2.shadow-light {
                 text-shadow: 4px 0 4px rgba(255,255,255,0.8);
             }
            h2.border-light {
                  text-shadow: 0 2px  rgba(235,235,235,0.8);
              }
            .reveal .dark h3,.reveal .dark h2, .reveal .dark p,.reveal .dark h1, .reveal .dark h5 {
                color: #fff;
            }
        </style>
        <!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Async Programming</h1>
					<h3>Rope ladders and quicksand shoes</h3>
					<p>
						<small>Created by <a href="http://bluefletch.com">Blake Byrnes</a> / <a href="http://twitter.com/blakebyrnes">@blakebyrnes</a></small>
					</p>
				</section>

				<section>
					<h2>Who am I?</h2>
					<h4>
						CTO of BlueFletch Mobile
					</h4>
					<p>
						I work with: <em>iOS, Android, nodejs, html5/ionic/cordova, AWS and sometimes .NET, Backend Java</em>
					</p>
				</section>

				<!-- -->
				<section>
					 <section  class="bg-blur" data-background-image="http://www.surface-tec.com/nanomech/images/nm5.jpg">
                         <h2>Why are we here?</h2>
					</section>
					<section>
						<h2>Async!</h2>
						<p>It's more important than you think.</p>
					</section>
                    <section class="bg-blur" data-background-image="https://www.rickscloud.com/wp-content/uploads/2014/05/rise_of_mobile-1280x880.jpg">
                        <h1>Rise of Mobile</h1>
                        <aside class="notes">
                            Poll audience on how many are doing mobile apps, or interested
                        </aside>
                    </section>
                    <section class="bg-blur" data-background-image="https://d85wutc1n854v.cloudfront.net/live/products/600x375/WB0977873.png?v=1.3">
                        <h1>Single Page Apps</h1>
                    </section>

                    <section class="bg-blur" data-background-image="http://media02.hongkiat.com/node-js/node-js.jpg">
                        <h1>Server Side Javascript</h1>
                    </section>

                    <section>
                       	<pre ><code data-trim style="font-size:40px !important">
$("#button").click(function(e){
  console.log("handle async.");
});
                        </code></pre>
                        <aside class="notes">
                            Client side - handle events
                        </aside>
                    </section>
                    <section data-background-image="http://i272.photobucket.com/albums/jj191/cpchristie/EasyButton.jpg">
                        <aside class="notes">
                            Some of you are saying, I went to the wrong class. Shit

                            Gets a lot harder when you start orchestrating multiple events
                        </aside>
                    </section>

                    <section>
                        <h2>Thinking asynchronously is hard...</h2>
                        <h2 class="fragment">But cheer up, Eventually you'll get it!</h2>
                    </section>
                    <section data-background-image="http://1.bp.blogspot.com/-wZfjvyBOpYc/U8MeaUFFFCI/AAAAAAAAAP0/0gRy-R1y638/s1600/Image-53.png">
                    </section>
                    <section>
                        <h2>Eventually you'll get it...</h2>
                    </section>
                    <section data-background-transition="slide" data-background-size="80%" data-background-image="http://s2.quickmeme.com/img/73/73d71fab45496a6671d670687eb359dd6293817166ddb699f7e1fb44358bad26.jpg">

                    </section>
					<section data-theme="black">
						<h2>You must learn it!</h2>
                        <img src="http://quotespics.com/wp-content/quote-images/patience-learn-you-must.jpg"/>
					</section>
                    <section data-background="black">
                        <img src="http://static.fjcdn.com/pictures/You_7900a8_1204562.jpg"/>
                    </section>
					<section>
						<h2>Real Email</h2>
						<p>"I am working on a appcelerator project for android and I see that the AJAX call  is not synchronous..   And because of this, my function (sic) populating the UI from the AJAX response is failing."</p>
					</section>
					<section>
						<p>Pseudo-code</p>
						<pre class=" smallest"><code class="javascript">
plugs.prototype.httpReq = function() {
  ...

  xhr.onload = function(e) {
    dataObj = JSON.parse(xhr.responseText)
  };

  xhr.open("GET", url,false);
  // Send the request.
  xhr.send();
};

plugs.prototype.populateData = function(){
  for(var i=0;i dataObj.length;i++) { //CRASH (dataObj is undefined)  
...

plugs.httpReq();
plugs.populateData();
						</code></pre>
						<aside class="notes">
							Developer didn't understand that the asynchronous code would perform out of order from the sequential order on the screen
						</aside>

					</section>
					<section>
						<h2><strong>Don't let this happen to you</strong></h2>
					</section>
					<section data-background-image="images/toolbelt.jpg">
						<h2 class="shadow-light">Add to your toolbelt</h2>
					</section>
				</section>
				<section>
					<h2>What is async?</h2>
					<section data-background-image="http://www.blastr.com/sites/blastr/files/styles/blog_post_media/public/running-man-05-g.jpg?itok=RuT52Pum" class="bg-blur">
						<h4>Code that doesn't wait!</h4>
						<p style="font-size: 1.5em">Will execute later</p>
                        <!-- running man picture -->
						<aside class="notes">
							Ever thought as you were leaving, "Remember to lock the door", then you did a bunch of other stuff, and then you finally got to the door, and remembered to lock it.  Kinda like that.

							Important to talk about how it doesn't block.  Implication is that it can get more out of the CPU where the code is running
						</aside>
					</section>
                    <section data-transition="fade-in" data-background-image="http://www.blastr.com/sites/blastr/files/styles/blog_post_media/public/running-man-05-g.jpg?itok=RuT52Pum" >
                     </section>
					<section>
						<p>User Interface</p>
						<!-- show someone about to hit a ui button -->
						<pre style="font-size:35px"><code data-trim>
$("#button").click(function(e){
  console.log("handle async");
});
						</code></pre>
						<aside class="notes">
							Client side - handle events
						</aside>
					</section>
					<section>
						<h4>I/O</h4>
						<p class="fragment">Network (ajax) requests</p>
						<p class="fragment">Database request</p>
						<p class="fragment">File reads/writes</p>
					</section>
					<section>
						<pre class="smaller"><code data-trim>
console.log(1);

$("#button").click();

console.log(2);

console.log(3);

//1
//click
//2
//3
						</code></pre>
					</section>
					<section>
						<pre><code data-trim>
console.log(1);

$("#button").click(function(e){
  console.log(2);
});

console.log(3);

//1
//3
//click: 2
						</code></pre>
					</section>
				</section>

				<section>
					<section data-background-image="http://4.bp.blogspot.com/-qL4EmKpjxrk/UKKGPp2VkTI/AAAAAAABlTM/iGren4CWVaw/s1600/running+man.png" class="dark">

                        <h2>The run loop</h2>
						<aside class="notes">
							Back to the running man.  He's going to keep running, until he runs into obstacles.
                            <br/>
                            Viewers are prompted once something is about to happen.  "Wait for execute"
						</aside>
					</section>
					<section data-background-image="http://i.stack.imgur.com/BTm1H.png" data-background="rgba(51,51,44, 255) center" data-background-size="contain"
                            data-background-repeat="no-repeat">
					</section>
					<section>
						<h5>Javascript (aka, the event loop)</h5>
						<pre><code>
  while(queue.waitForMessage()){
    queue.processNextMessage();
  }

</code></pre>
						<aside class="notes">
							In web browsers, messages are added any time an event occurs and there is an event listener attached to it.
						</aside>
					</section>
					<section>
						<h5>Timers Demystified</h5>
						<pre><code>
  setTimeout(delayedFunction, 100);

</code></pre>
<br/>
						<p class="fragment">Just pops onto the event loop after 100 ms*</p>
						<p class="fragment"><i>*kind of</i></p>
						<aside class="notes">
							Calling setTimeout will add a message to the queue after the time passed as second argument. 
						</aside>
					</section>
				</section>
				<section>
					<section class="dark bg-fade" data-background="http://brianschrader.com/images/blog/branches.png">
						<h3 class="shadow"><strong>Asynchronous === Multi-Threading?</strong></h3>

						<aside class="notes">
                            - Async not <i>necessarily</i> multi-threaded
                            <br/>
                            - Multi-threading === run heavy process in background
                            <br/>
                            - Language dependent
                            <br/>
                            - If op doesn't require CPU, that operation can be done without spawning another thread (i/o, hardware notification)

							<a href="http://stackoverflow.com/questions/600795/asynchronous-vs-multithreading-is-there-a-	difference">stack overflow</a>
						</aside>
					</section>
				</section>
				<section>
					<h1>Ok, got it</h1>
					<h3>Is there anything more?</h3>
				</section>
                <section data-background-size="contain" data-background="black center" data-background-repeat="no-repeat" data-background-image="http://4.bp.blogspot.com/-Z8e-Y0JcrtQ/UdNzG2ZNoJI/AAAAAAAAQks/yz7rpQ5ItlU/s500/wfg32.gif"></section>

				<section  data-background-color="black" >
					<h2 style="color:#fff">Why is it hard?</h2>
                    <section data-background-image="">

                    </section>
					<section data-background-repeat="no-repeat" data-background-image="http://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/Apple_logo_Think_Different_vectorized.svg/2000px-Apple_logo_Think_Different_vectorized.svg.png" data-background-size="contain" data-background="black center" >

						<aside class="notes">Different way of thinking</aside>
					</section>
					<section>
                        <img src="http://www.blogcdn.com/www.autoblog.com/media/2009/06/bttf_time_machine_ebay_lead.jpg"/>
						<aside class="notes">
							Have to start thinking about what will eventually happen.  If this, then this, then this..

							Log a function to occur eventually, written now
						</aside>

					</section>
					<section>
						<img src="http://jordankasper.com/js-testing/images/meme-functions.jpg">
						<aside class="notes">
							Break it down into units
						</aside>
					</section>

					<section>
						<img style="margin-top:100px" src="http://www.huckleberrybicycles.com/wp-content/uploads/2012/08/IMG_3576-copy.jpeg"/>
						<aside class="notes">
							By the time your "asynchronous" code is done, your view might not be there anymore

							Android example (activity requests a network resource, puts in a callback handler, gone when it returns)
						</aside>
					</section>
					<aside class="notes">
						I've done these callbacks, why is this a big deal?
					</aside>

				</section>

				<section>
					<h2>What can go wrong?</h2>
				</section>

				<section data-background="black">
					<img src="images/Heaven-or-Hell-Arrow-Way-Line-Route.jpg"/>
				</section>
				<section>
					<h3>Add 5 new features</h3>
					<pre class="smallest stretch" ><code>
fs.readdir(source, function(err, files) {
  if (err) {
    console.log('Error finding files: ' + err);
  } else {
    files.forEach(function(filename, fileIndex) {
      console.log(filename);
      gm(source + filename).size(function(err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values);
          aspect = (values.width / values.height);
          widths.forEach(function(width, widthIndex) {
            height = Math.round(width / aspect);
            console.log('resizing ' + filename + 'to ' + height + 'x' + height);
            var fn = destination + 'w' + width + '_' + filename;
            this.resize(width, height).write(fn, function(err) {
              if (err) console.log('Error writing file: ' + err);
            });
          }.bind(this));
        }
      });
    });
  }
});
                    </code></pre>
				</section>
				<section>
					<h3>Example - can't change backend</h3>
					<ol>
						<li class="fragment">Load blog</li>
						<li class="fragment">Load author</li>
						<li class="fragment">Load comments</li>
						<li class="fragment">Load each commentor user profile</li>
					</ol>
				</section>
				<section>
					<pre class="smallest stretch" ><code style="font-size:25px !important; line-height:30px">
var blog = {};
$.get('/blogs/1', function(data){
  blog = data;
  
  $.get('/users/' + data.authorId, function(author){
    blog.author = author;
  });

  $.get('/blogs/1/comments', function(comments){
    blog.comments = comments;
    comments.forEach(function(comment){
      $.get('/users/' + data.authorId, function(author){
        comment.author = author;
      });
    });
  });
});
                    </code></pre>
				</section>

				<section>
					<h2>How it starts</h2>
					<pre class="smallest stretch" ><code class="javascript">
var blog = {};
$.get('/blogs/1', function(data){
  blog = data;

  //NEW! Featured Articles
  if (blog.isFeatured){
    $.get('/ads', function(data){
      //load ad and display in main content div
    }).fail(function(){
      //TODO: download comments/authors like a normal article... copy here??
    });
  } else {
    
    $.get('/users/' + data.authorId, function(author){
      blog.author = author;
    });

    $.get('/blogs/1/comments', function(comments){
      blog.comments = comments;
      comments.forEach(function(comment){
        $.get('/users/' + data.authorId, function(author){
          comment.author = author;
        });
      });
    });
  }
});
                    </code></pre>
				</section>
				<section>
					<section>
						<h2>Small branches continue to nest logic</h2>
					</section>
					<section>
						<h2>Eventually, you lose</h2>
					</section>
					<section>
						<pre class="smallest stretch" ><code class="javascript" data-trim>
_makePostAppend: function( params, body, options, next ){

    var self = this;
    var body;

    if( typeof( next ) !== 'function' ) next = function(){};

    // Check that the method is implemented
    if( ! self.handlePostAppend ){
      self._sendError( next, new self.NotImplementedError( ) );
      return;
    }

    // Check the IDs
    self._checkParamIds( params, body, false, function( err ){  
      self._sendErrorOnErr( err, next, function(){

        self.schema.validate(  body, function( err, body, errors ) {
          self._sendErrorOnErr( err, next, function(){

            if( errors.length ){
              self._sendError( next, new self.UnprocessableEntityError( { errors: errors } ) );
            } else {
             // Fetch the doc
              self.execAllDbFetch( params, body, options, function( err, fullDoc ){
                self._sendErrorOnErr( err, next, function(){
                 self.extrapolateDoc( params, body, options, fullDoc, function( err, doc) {
                    self._sendErrorOnErr( err, next, function(){
                        </code></pre>
					</section>
					<section>
						<h5>continued</h5>
						<pre class="smallest stretch" ><code class="javascript">
               
                      self._castDoc( doc, function( err, doc) {
                        self._sendErrorOnErr( err, next, function(){

                          // Actually check permissions
                          self.checkPermissionsPostAppend( params, body, options, doc, fullDoc, function( err, granted ){
                            self._sendErrorOnErr( err, next, function(){

                              if( ! granted ){
                                self._sendError( next, new self.ForbiddenError() );
                              } else {

                                // Clean up body from things that are not to be submitted
                                //if( self.schema ) self.schema.cleanup( body, 'doNotSave' );
                                self.schema.cleanup( body, 'doNotSave' );

                                // Paranoid check
                                // Make sure that the id property in the body does match
                                // the one passed as last parameter in the list of IDs
                                body[ self.idProperty ] = params[ self.idProperty ];

                                self.execPostDbAppend( params, body, options, doc, fullDoc, function( err, fullDocAfter ){

                        </code></pre>
					</section>
					<section>
						<h5>continued</h5>
						<pre class="smallest stretch" ><code class="javascript">
                                  self._sendErrorOnErr( err, next, function(){
                                    self.extrapolateDoc( params, body, options, fullDocAfter, function( err, doc) {
                                      self._sendErrorOnErr( err, next, function(){

                                        self._castDoc( fullDocAfter, function( err, docAfter) {
                                          self._sendErrorOnErr( err, next, function(){

                                            // Remote request: set headers, and send the doc back (if echo is on)
                                            if( self.remote ){
                                              if( self.echoAfterPostAppend ){

                                                 self.prepareBeforeSend( docAfter, function( err, docAfter ){
                                                   self._sendErrorOnErr( err, next, function(){

                                                      self.afterPostAppend( params, body, options, doc, fullDoc, docAfter, fullDocAfter, function( err ){
                                                        self._sendErrorOnErr( err, next, function(){

                                                          self._res.json( 200, docAfter );

                                                        });
                                                      });
                                                   })
                                                 })
                                              } else { 
                                                self.afterPostAppend( params, body, options, doc, fullDoc, docAfter, fullDocAfter, function( err ){
                        </code></pre>
					</section>
					<section>
						<h5>continued</h5>
						<pre class="smallest stretch" ><code class="javascript">
                                                  self._sendErrorOnErr( err, next, function(){

                                                    self._res.send( 204, '' );

                                                  });
                                                });

                                              }
                                            // Local request: simply return the doc to the asking function
                                            } else {

                                              self.prepareBeforeSend( docAfter, function( err, docAfter ){
                                                self._sendErrorOnErr( err, next, function(){

                                                  self.afterPostAppend( params, body, options, doc, fullDoc, docAfter, fullDocAfter, function( err ){
                                                    self._sendErrorOnErr( err, next, function(){

                                                      next( null, docAfter, self.idProperty );

                                                    })
                                                  })

                                                })
                                              })
                                            }
                        </code></pre>
					</section>
					<section>
						<h5>finally</h5>
						<pre class="smallest stretch" ><code class="javascript">
                                          })
                                        });
                                      });
                                    })
                                  }) // err
                                }) // execPostDbAppend

                              } // granted

                            })
                          }) 

                        }) 
                      }) 
                    })
                  }) 
                }) // err
              }) // checkPermissionsPostAppend
            } // errors.length

          }) // err
        }) // self.validate
      }) // err
    }) // self.validate
  },

                        </code></pre>
					</section>
					<section>
						<pre class="smallest stretch" ><code class="javascript" style="font-size:6px;line-height:4px;">
_makePostAppend: function( params, body, options, next ){

    var self = this;
    var body;

    if( typeof( next ) !== 'function' ) next = function(){};

    // Check that the method is implemented
    if( ! self.handlePostAppend ){
      self._sendError( next, new self.NotImplementedError( ) );
      return;
    }

    // Check the IDs
    self._checkParamIds( params, body, false, function( err ){  
      self._sendErrorOnErr( err, next, function(){

        self.schema.validate(  body, function( err, body, errors ) {
          self._sendErrorOnErr( err, next, function(){

            if( errors.length ){
              self._sendError( next, new self.UnprocessableEntityError( { errors: errors } ) );
            } else {

              // Fetch the doc
              self.execAllDbFetch( params, body, options, function( err, fullDoc ){
                self._sendErrorOnErr( err, next, function(){


                  self.extrapolateDoc( params, body, options, fullDoc, function( err, doc) {
                    self._sendErrorOnErr( err, next, function(){

                      self._castDoc( doc, function( err, doc) {
                        self._sendErrorOnErr( err, next, function(){

                          // Actually check permissions
                          self.checkPermissionsPostAppend( params, body, options, doc, fullDoc, function( err, granted ){
                            self._sendErrorOnErr( err, next, function(){

                              if( ! granted ){
                                self._sendError( next, new self.ForbiddenError() );
                              } else {

                                // Clean up body from things that are not to be submitted
                                //if( self.schema ) self.schema.cleanup( body, 'doNotSave' );
                                self.schema.cleanup( body, 'doNotSave' );

                                // Paranoid check
                                // Make sure that the id property in the body does match
                                // the one passed as last parameter in the list of IDs
                                body[ self.idProperty ] = params[ self.idProperty ];

                                self.execPostDbAppend( params, body, options, doc, fullDoc, function( err, fullDocAfter ){
                                  self._sendErrorOnErr( err, next, function(){

                                    self.extrapolateDoc( params, body, options, fullDocAfter, function( err, doc) {
                                      self._sendErrorOnErr( err, next, function(){

                                        self._castDoc( fullDocAfter, function( err, docAfter) {
                                          self._sendErrorOnErr( err, next, function(){

                                            // Remote request: set headers, and send the doc back (if echo is on)
                                            if( self.remote ){
                                              if( self.echoAfterPostAppend ){

                                                 self.prepareBeforeSend( docAfter, function( err, docAfter ){
                                                   self._sendErrorOnErr( err, next, function(){

                                                      self.afterPostAppend( params, body, options, doc, fullDoc, docAfter, fullDocAfter, function( err ){
                                                        self._sendErrorOnErr( err, next, function(){

                                                          self._res.json( 200, docAfter );

                                                        });
                                                      });
                                                   })
                                                 })
                                              } else { 

                                                self.afterPostAppend( params, body, options, doc, fullDoc, docAfter, fullDocAfter, function( err ){
                                                  self._sendErrorOnErr( err, next, function(){

                                                    self._res.send( 204, '' );

                                                  });
                                                });

                                              }

                                            // Local request: simply return the doc to the asking function
                                            } else {

                                              self.prepareBeforeSend( docAfter, function( err, docAfter ){
                                                self._sendErrorOnErr( err, next, function(){

                                                  self.afterPostAppend( params, body, options, doc, fullDoc, docAfter, fullDocAfter, function( err ){
                                                    self._sendErrorOnErr( err, next, function(){

                                                      next( null, docAfter, self.idProperty );

                                                    })
                                                  })

                                                })
                                              })
                                            }

                                          })
                                        });

                                      });
                                    })


                                  }) // err
                                }) // execPostDbAppend

                              } // granted


                            })
                          }) 

                        }) 
                      }) 

                    })
                  }) 

                }) // err
              }) // checkPermissionsPostAppend

            } // errors.length

          }) // err
        }) // self.validate

      }) // err
    }) // self.validate
  },

                        </code></pre>
					</section>
					<section>
						<h1>Convinced?</h1>
					</section>
				</section>

				<section>
					<h2>Where will I find async?</h2>
					<section>
						<h3>Producers</h3>
						<p class="fragment">User Interface</p>
						<p class="fragment">Models</p>
						<p class="fragment">Ajax</p>
						<p class="fragment">System Changes</p>
						<aside class="notes">
							UI - broadcast events
							Models - staet changes
							Ajax - complete/error
							System - wifi, location, battery changes
						</aside>
					</section>
					<section>
						<h3>Consumers</h3>
						<p class="fragment">Views</p>
						<p class="fragment">Controllers</p>
						<p class="fragment">Models</p>
						<aside class="notes">
							Views - update when state changes
							Controllers - direct action on events
							Models - change when other models change
						</aside>
					</section>
				</section>

				<section data-background-image="http://www.businessnewsdaily.com/images/i/000/000/415/original/problem-solving.jpg?1323472010" class="bg-blur">
					<h2>Problems to Solve</h2>
				</section>
				<section data-background-image="http://gb.fotolibra.com/images/previews/49824-stages-of-rocket-launching-illustration.jpeg" class="bg-fade">
					<h2>Long Tasks One After Another</h2>
					<aside class="notes">
						think ajax, file uploads
					</aside>
				</section>

				<section data-background-image="http://static2.bigstockphoto.com/thumbs/5/6/3/large2/36542230.jpg" class="bg-blur">
					<h2>Long Tasks at once</h2>
					<aside class="notes">
						think ajax, file uploads
					</aside>
				</section>

				<section data-background-image="http://i.ytimg.com/vi/d4ExlhrSnG4/maxresdefault.jpg" class="bg-fade">
					<h2 class="border-light">Wait for tasks to finish</h2>
					<aside class="notes">
						after all ajax downloaded, display view
					</aside>
				</section>

				<section>
					<h2>Run Task without Blocking UI</h2>
					<aside class="notes">
						facebook detects dom changes in background (ie, react)
					</aside>
				</section>
				<section>
					<h2>Handling Errors</h2>
					<aside class="notes">
						handle errors that crop up in your application
						unhandled exceptions, 
					</aside>
				</section>
				<section>
					<h2>Dynamic or Complicated Workflows</h2>
					<aside class="notes">
						Complicated sequence of activities that have lots of branching and flows might need an event system
					</aside>
				</section>
				<section>
					<h2>Handling Triggered Events</h2>
					<aside class="notes">
						System events, UI events, etc.  Handle changes and react to them
					</aside>
				</section>
				
				<section>
					<h2>Patterns</h2>
					<p class="fragment">aka, Great, what do I do with this knowledge?</p>
				</section>

				<section>
					<h2>Callbacks</h2>
					<section>
						<p>Call me later</p>
					</section>
					<section>
						<pre class="smaller"><code>
  readABigFile('filename.jpg', 
    function afterRead(error, file){
      console.log("Here's my file " + file);
    });
						</code></pre>
					</section>
					<section>
						<pre class="smaller"><code style="font-size:24px">
  readABigFile(new OnFileReadListener(){
     @Override
     public void onFileRead(File file){
        Log.d(TAG, "Read file " + file);
     }
     @Override
     public void onError(Exception e){
        Log.e(TAG, "Error reading file " + e);
     }
  });
						</code></pre>
					</section>
                    <section>
						<pre class="smaller"><code style="font-size:24px">
  readABigFile(file -> {
    Log.d(TAG, "Read file " + file);
  },
  ex -> {
    Log.e(TAG, "Error reading file " + e);
  });
                        </code></pre>
                        <aside class="notes">
                            CHEERS!

                            TODO: slide with applause?
                        </aside>
                    </section>
					<section>
						<h5>Positives</h5>
						<p>Built-in</p>
						<aside class="notes">
							No 3rd party necessary
						</aside>
					</section>
					<section>
						<h5>Positives</h5>
						<p>Easy to Read</p>
					</section>
					<section>
						<h5>Negatives</h5>
						<p>Multiple calls quickly devolve</p>
						<aside class="notes">
							Nested calls
						</aside>
					</section>
					<section>
						<h5>Negatives</h5>
						<p>Program stalls if not called</p>
						<p><i>happens more than you'd expect</i></p>
						<aside class="notes">
							If you return and forget to call the callback, the code won't ever continue.  This is a fundamental difference from sequential programs.
						</aside>
					</section>
					<section>
						<h5>When to use</h5>
						<p>Simple use cases (most)</p>
						<aside class="notes">
							A lot of code doesn't need some higher level abstraction.  Don't go down a path of libraries and patterns if you don't need them.
						</aside>
					</section>
				</section>
				<section>
					<h2>Callback Libraries</h2>
					<section>
						<p>Add coordination across callbacks</p>
					</section>
					<section>
						<h5>Positives</h5>
						<p>Consistent structure for calls</p>
					</section>
					<section>
						<h5>Negatives</h5>
						<p>Third Party Library</p>
					</section>
					<section>
						<h5>Negatives</h5>
						<p>Enforced Opinion</p>
					</section>
					<section>
						<h5>Negatives</h5>
						<p>Still inherit some problems of callbacks</p>
					</section>
					<section>
						<h5>javascript</h5>
						<p>async.js</p>
						TODO: quick example
					</section>
					<section>
						<h5>Android</h5>
						<p>Bolts</p>
						<pre class="smallest stretch" ><code>
ParseQuery<ParseObject> query = ParseQuery.getQuery("Comments");
query.whereEqualTo("post", 123);

findAsync(query).continueWithTask(new Continuation<List<ParseObject>, Task<Void>>() {
  public Task<Void> then(Task<List<ParseObject>> results) throws Exception {
    // Collect one task for each delete into an array.
    ArrayList<Task<Void>> tasks = new ArrayList<Task<Void>>();
    for (ParseObject result : results) {
      // Start this delete immediately and add its task to the list.
      tasks.add(deleteAsync(result));
    }
    // Return a new task that will be marked as completed when all of the deletes are
    // finished.
    return Task.whenAll(tasks);
  }
}).onSuccess(new Continuation<Void, Void>() {
  public Void then(Task<Void> ignored) throws Exception {
    // Every comment was deleted.
    return null;
  }
});
						</code></pre>
                        <aside class="notes">
                            https://github.com/BoltsFramework/Bolts-Android
                        </aside>
					</section>
				</section>

				<section>
					<h2>Delegation Pattern</h2>
					<section>
						Hand off control to 1 other actor
						<aside class="notes">
						Android: think, registering activity callback when an action happens in a fragment (clicked on button)
						</aside>
					</section>
					<section>
						TODO: Android example (listener)
					</section>
					<section>
						<h5>Positives</h5>
						<p>Two-way Control</p>
					</section>
					<section>
						<h5>Positives</h5>
						<p>Very Clear API (interface)</p>
					</section>
					<section>
						<h5>Negatives</h5>
						<p>Switching Listener</p>
					</section>
					<section>
						<h5>When to use</h5>
						<p>Clear pattern that needs to be handled by listener</p>
						<p>One listener/actor</p>
					</section>
					<section>
						<h5>When to use</h5>
						<p>UI Component 1-to-1 "Worker"</p>
						<p>"Instance" of service layer</p>
						<p>Service layer coupled to single view</p>
					</section>
				</section>
				<section>
					<h2>Observer Pattern</h2>
                    <section>
                        "Observe" an object's events
                    </section>
                    <section>
                        <h5>Positives</h5>
                        <p>Loose Coupling</p>
                        <aside class="notes">
                            Publisher doesn't know who is listening
                        </aside>
                    </section>
                    <section>
                        <h5>Positives</h5>
                        <p>Specific Object of Interest</p>
                        <aside class="notes">
                            Not just willy-nilly listening to events.  Most of the time this is great, but sometimes you need to know a "new object" got created.
                        </aside>
                    </section>
                    <section>
                        <h5>Positives</h5>
                        <p>One or Many Subscribers</p>
                    </section>
                    <section>
                        <h5>Negatives</h5>
                        <p>Memory Loops</p>
                        <aside class="notes">
                            View might disappear, but still registered for events
                        </aside>
                    </section>
                    <section>
                        <h5>Negatives</h5>
                        <p>Stateless</p>
                        <aside class="notes">
                            You usually only hear events, so you need to handle synchronously, and then also in your async block
                        </aside>
                    </section>
                    <section>
                        <h5>Negatives</h5>
                        <p>Often String-based Event Names</p>
                        <aside class="notes">
                            Can make intent of the api a little tough to follow.  There's no self-documenting structure in many cases.
                        </aside>
                    </section>
                    <section>
                        <h5>When to Use</h5>
                        <p>View/Model Changes</p>
                        <p>Backbone.js</p>
                        <p>DOM</p>
                    </section>
				</section>
				<section>
					<h2>Promises</h2>
                    <section>
                        Object that will <i>always</i> either resolve or reject
                    </section>
                    <section>
                        Simplified model of async
                    </section>
                    <section>
                        Run handlers on different threads (if necessary)
                    </section>
                    <section>
                        TODO: ANDROID/JDEFERRED EXAMPLE
                    </section>
                    <section>
                        TODO: JAVASCRIPT EXAMPLE
                    </section>
                    <section>
                        <h5>Positives</h5>
                        <p>Mimics Synchronous Code</p>
                        <aside class="notes">
                            Looks like synchronous code
                        </aside>
                    </section>
                    <section>
                        <h5>Positives</h5>
                        <p>Error Handling</p>
                        <aside class="notes">
                            Easily bubble up typed errors, catch uncaught exceptions.

                            One gotcha - syntax can take a second error handler.  You should still have a good strategy for sending up typed errors or handling them as they occur.  Treat it like Try/Catch rules.
                        </aside>
                    </section>
                    <section>
                        <h5>Positives</h5>
                        <p>All Paths Exit</p>
                        <aside class="notes">
                            You can't screw up and get stuck.  It will always go to the next block
                        </aside>
                    </section>
                    <section>
                        <h5>Positives</h5>
                        <p>Resolve Immedeiately</p>
                        <aside class="notes">
                            Return state immediately and still go to the callbacks
                        </aside>
                    </section>
                    <section>
                        <h5>Negatives</h5>
                        <p>External Library</p>
                        <aside class="notes">
                            Libs implement different versions of what it means to have "Promises". Luckily, most things are converting to follow the Promises/A standard.
                        </aside>
                    </section>
                    <section>
                        <h5>Negatives</h5>
                        <p>Can Discourage Testing "Units"</p>
                        <aside class="notes">
                            In practice, it feels a little common to put your code in a promise block and deal with it right there.  This isn't a science, just an observed behavior.
                        </aside>
                    </section>
                    <section>
                        <h5>Negatives</h5>
                        <p>Hard to De-register</p>
                        <aside class="notes">
                            In some of the libraries, it can be hard to cancel the promises if your view goes out of scope.
                        </aside>
                    </section>
                    <section>
                        <h5>Negatives</h5>
                        <p>Hard to Write your own Initially</p>
                        <aside class="notes">
                            For some reason, the behavior of promises can be a little confusing to write for yourself initially
                        </aside>
                    </section>
                    <section>
                        <h5>When to Use</h5>
                        <p>Backend Ajax -> DB Storage</p>
                        <p>Multiple calls must complete before moving on</p>
                        <p>Load from file or DB</p>
                        <p>When it's available (lib included/supported)</p>
                    </section>
				</section>
				<section>
					<h2>Message Bus</h2>
                    <section>
                        Central service for sending and receiving messages
                    </section>
                    <section>
                    	Otto example
                    </section>
                    <section>
                    	jQuery example
                    </section>
                    <section>
                        <h5>Positives</h5>
                        <p>Completely De-Coupled</p>
                        <aside class="notes">
                            Neither receivers or publishers know about each other
                        </aside>
                    </section>
                    <section>
                        <h5>Positives</h5>
                        <p>Work on front-end/backend independently</p>
                        <aside class="notes">
                            Makes it so services can come and go, and anyone can subscribe to events and register themselves
                        </aside>
                    </section>
                    <section>
                        <h5>Positives</h5>
                        <p>Components can self-register</p>
                        <aside class="notes">
                            You can have an app boot-up that skips the 1 by 1 registration of your app services; they just self register
                        </aside>
                    </section>
                    
                    <section>
                        <h5>Negatives</h5>
                        <p>Hard to trace/understand</p>
                        <aside class="notes">
                            Searching through the codebase for where events come from can be challenging.  Same with refactoring.

                            Not self-documenting
                        </aside>
                    </section>
                    <section>
                        <h5>Negatives</h5>
                        <p>Messy Quickly</p>
                        <aside class="notes">
                            If this is your only pattern, you'll find you need to be diligent not to publish events from other handlers.  This starts too much of a cascading SOA without a central mechanism to see the flows
                        </aside>
                    </section>
                    <section>
                        <h5>Negatives</h5>
                        <p>1 Way</p>
                        <aside class="notes">
                        	Not meant for fine-grained state
                        	If you pub to sub, might get events initiated by something else
                        
                            If your event can be broadcast for multiple objects, gets noisy (think blog:updated.  must filter each one by the blog id)

                            Think about posting to the bus about "creating" a new blog.  If you care about the result, you need to subscribe to the "BlogCreated" event, and then figure out if it's yours, or something else.
                        </aside>
                    </section>
                    <section>
                        <h5>Negatives</h5>
                        <p>Too easy to take too far</p>
                        <aside class="notes">
                            You don't want to initiate async events on a hub just to load data.  Only do this for things that you don't care if they're not going to return until later
                        </aside>
                    </section>
                    <section>
                        <h5>When to use</h5>
                        <p>System-wide events</p>
                        <p>Want to handle EVERY event</p>
                        <p>Cross-model events</p>
                        <p>If you can easily filter events (not Otto)</p>
                    </section>
				</section>
				<section>
					<h2>coroutines</h2>
                    <section>
                        Keywords built into language to handle async
<pre><code>
  yield, await, async
</code></pre>
                        <aside class="notes">
                            Built-in to EmcaScript 6 (EC6)
                        </aside>
                    </section>
                    <section>
                        Built into Javascript (EC6), .NET
                    </section>
                    <section>
                    	<pre><code>
                            TODO: yield example
                        </code></pre>
                    </section>
                    <section>
                        <h5>Positives</h5>
                        <p>Native support</p>
                        <aside class="notes">
                            Built right in, so easy to use.

                            In JS, acts like it returns a promise, so you can chain, etc
                        </aside>
                    </section>
                    <section>
                        <h5>Positives</h5>
                        <p>Looks synchronous</p>
                        <aside class="notes">
                            Much harder to create spaghetti code.  Still has all the benefits of async on the cpu
                        </aside>
                    </section>
                    <section>
                        <h5>Positives</h5>
                        <p>Easy to read/grasp</p>
                        <aside class="notes">
                            Flow of code is easy to spot
                        </aside>
                    </section>
                    <section>
                        <h5>Negatives</h5>
                        <p>Won't Stop you Nesting</p>
                        <aside class="notes">
                            You can still "nest", it's just not quite as verbose.  Still need to think about structuring units of code
                        </aside>
                    </section>
                    <section>
                        <h5>Negatives</h5>
                        <p>Not quite ready</p>
                        <aside class="notes">
                            Need transpiler in javascript
                        </aside>
                    </section>

				</section>

                <section>
                    <h2>Reactive Programming</h2>
                    <p>Combo-moves!</p>
                    <aside class="notes">
                        Too much for this presentation, but includes
                    </aside>
                </section>

				<section>
					<h2>Tips/Tricks</h2>
					<section>
						2 deep!
					</section>
					<section>
						Aim for vertical
						<aside class="notes">
							Karate chop
                        </aside>
					</section>
					<section>
						Avoid Diagonal
					</section>
					<section>
						Focus on readability
					</section>
                    <section>
                        De-register when Views Disappear
                        <aside class="notes">
                            If you reference views/elements that might be gone when your callback runs, you may end up killing your app.  This is true of almost every async pattern and is something you need to think about.

                            Backbone handles this for you by inversing the ownership of the model events so that the view holds the registration and will kill them off on destroy.
                        </aside>
                    </section>
					<section>
						Write testable functions, then add coordination
						<aside class="notes">
							This helps to think in terms of little units, as well as testing
						</aside>
					</section>
					<section>
						Refactor as you write and notice code nesting
					</section>
					<section>
						Don't be clever.  Use patterns when you need them!!!
					</section>
					<section>
						Choose your own adventure... once
						<aside class="notes">
						Avoid too many patterns at once (choose your own adventure)
						</aside>
					</section>
					<section>
						Choose the pattern that fits your problem-set:
						 - System Wide: message bus
						 - Downloads/Waterfall Events: Promises/Callback Coordinators
						 - Random Events: message bus/state machine
					     - React to Individual Model/View: observer
					</section>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: false,
				progress: true,
				history: true,
				center: true,
				slideNumber: true,
				keyboard: {
	              g: 'slide' // go to the next slide when the ENTER key is pressed
	            },

				transition: 'convex', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
